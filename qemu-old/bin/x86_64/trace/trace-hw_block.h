/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_BLOCK_GENERATED_TRACERS_H
#define TRACE_HW_BLOCK_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_FDC_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_FDC_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_RESET_EVENT;
extern TraceEvent _TRACE_PFLASH_TIMER_EXPIRED_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_MANUFACTURER_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_INFO_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_RW_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_LCHS_GUESS_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_GUESS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_REGISTER_NAMESPACE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IRQ_MSIX_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IRQ_PIN_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IRQ_MASKED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DMA_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_ADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_ADDR_CMB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_PRP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MAP_SGL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IO_CMD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ADMIN_CMD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_RW_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_BLOCK_STATUS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DSM_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DSM_DEALLOCATE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COMPARE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_COMPARE_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AIO_DISCARD_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AIO_ZONE_RESET_CB_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CREATE_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CREATE_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DEL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_DEL_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_CTRL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NS_CSI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NSLIST_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_CMD_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GET_LOG_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_VWCACHE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_NUMQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SETFEAT_NUMQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SETFEAT_TIMESTAMP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_GETFEAT_TIMESTAMP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_PROCESS_AERS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_AERL_EXCEEDED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_MASKED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_AER_POST_CQE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_EVENT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_NO_OUTSTANDING_AERS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_DOORBELL_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_DOORBELL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_INTM_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_INTM_CLR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_CFG_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_AQATTR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ASQADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ACQADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ASQADDR_HI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_ACQADDR_HI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_START_SUCCESS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_STOPPED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_OPEN_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CLOSE_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_FINISH_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_RESET_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_OFFLINE_ZONE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ZD_EXTENSION_SET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CLEAR_NS_CLOSE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_CLEAR_NS_RESET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_MDTS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_REQ_STATUS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ADDR_READ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ADDR_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_CFS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_AIO_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_SGLD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DMA_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_OPC_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_IS_FULL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_APPEND_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_IOCSCI_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_GETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_SETFEAT_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_NBARASQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_NBARACQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_CSS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_STARTFAIL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIOWR_INVALID_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_EVENT;
extern TraceEvent _TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_CONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DISCONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_SIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_ADD_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_DEL_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_DESTROY_EVENT;
extern TraceEvent _TRACE_M25P80_FLASH_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_EVENT;
extern TraceEvent _TRACE_M25P80_RESET_DONE_EVENT;
extern TraceEvent _TRACE_M25P80_COMMAND_DECODED_EVENT;
extern TraceEvent _TRACE_M25P80_COMPLETE_COLLECTING_EVENT;
extern TraceEvent _TRACE_M25P80_POPULATED_JEDEC_EVENT;
extern TraceEvent _TRACE_M25P80_CHIP_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_SELECT_EVENT;
extern TraceEvent _TRACE_M25P80_PAGE_PROGRAM_EVENT;
extern TraceEvent _TRACE_M25P80_TRANSFER_EVENT;
extern TraceEvent _TRACE_M25P80_READ_BYTE_EVENT;
extern TraceEvent _TRACE_M25P80_READ_DATA_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_NO_BDRV_EVENT;
extern uint16_t _TRACE_FDC_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_FDC_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_RESET_DSTATE;
extern uint16_t _TRACE_PFLASH_TIMER_EXPIRED_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_MANUFACTURER_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_INFO_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_RW_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_LCHS_GUESS_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_GUESS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_REGISTER_NAMESPACE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IRQ_MSIX_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IRQ_PIN_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IRQ_MASKED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DMA_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_ADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_ADDR_CMB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_PRP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MAP_SGL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IO_CMD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ADMIN_CMD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_RW_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_BLOCK_STATUS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DSM_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DSM_DEALLOCATE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COMPARE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_COMPARE_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AIO_DISCARD_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AIO_ZONE_RESET_CB_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CREATE_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CREATE_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DEL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_DEL_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_CTRL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NS_CSI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NSLIST_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_CMD_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GET_LOG_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_VWCACHE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_NUMQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SETFEAT_NUMQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SETFEAT_TIMESTAMP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_GETFEAT_TIMESTAMP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_PROCESS_AERS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_AERL_EXCEEDED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_MASKED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_AER_POST_CQE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_EVENT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_NO_OUTSTANDING_AERS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_DOORBELL_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_DOORBELL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_INTM_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_INTM_CLR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_CFG_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_AQATTR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ASQADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ACQADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ASQADDR_HI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_ACQADDR_HI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_START_SUCCESS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_STOPPED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_OPEN_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CLOSE_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_FINISH_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_RESET_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_OFFLINE_ZONE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ZD_EXTENSION_SET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CLEAR_NS_CLOSE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_CLEAR_NS_RESET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_MDTS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_REQ_STATUS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ADDR_READ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ADDR_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_CFS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_AIO_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_SGLD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DMA_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_OPC_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_IS_FULL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_APPEND_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_IOCSCI_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_GETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_SETFEAT_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_NBARASQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_NBARACQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_CSS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_STARTFAIL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIOWR_INVALID_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_DSTATE;
extern uint16_t _TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_CONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DISCONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_SIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_ADD_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_DEL_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_DESTROY_DSTATE;
extern uint16_t _TRACE_M25P80_FLASH_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_DSTATE;
extern uint16_t _TRACE_M25P80_RESET_DONE_DSTATE;
extern uint16_t _TRACE_M25P80_COMMAND_DECODED_DSTATE;
extern uint16_t _TRACE_M25P80_COMPLETE_COLLECTING_DSTATE;
extern uint16_t _TRACE_M25P80_POPULATED_JEDEC_DSTATE;
extern uint16_t _TRACE_M25P80_CHIP_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_SELECT_DSTATE;
extern uint16_t _TRACE_M25P80_PAGE_PROGRAM_DSTATE;
extern uint16_t _TRACE_M25P80_TRANSFER_DSTATE;
extern uint16_t _TRACE_M25P80_READ_BYTE_DSTATE;
extern uint16_t _TRACE_M25P80_READ_DATA_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_NO_BDRV_DSTATE;
#define TRACE_FDC_IOPORT_READ_ENABLED 1
#define TRACE_FDC_IOPORT_WRITE_ENABLED 1
#define TRACE_PFLASH_RESET_ENABLED 1
#define TRACE_PFLASH_TIMER_EXPIRED_ENABLED 1
#define TRACE_PFLASH_IO_READ_ENABLED 1
#define TRACE_PFLASH_IO_WRITE_ENABLED 1
#define TRACE_PFLASH_DATA_READ_ENABLED 1
#define TRACE_PFLASH_DATA_WRITE_ENABLED 1
#define TRACE_PFLASH_MANUFACTURER_ID_ENABLED 1
#define TRACE_PFLASH_DEVICE_ID_ENABLED 1
#define TRACE_PFLASH_DEVICE_INFO_ENABLED 1
#define TRACE_VIRTIO_BLK_REQ_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_RW_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_WRITE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_READ_ENABLED 1
#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_ENABLED 1
#define TRACE_HD_GEOMETRY_LCHS_GUESS_ENABLED 1
#define TRACE_HD_GEOMETRY_GUESS_ENABLED 1
#define TRACE_PCI_NVME_REGISTER_NAMESPACE_ENABLED 1
#define TRACE_PCI_NVME_IRQ_MSIX_ENABLED 1
#define TRACE_PCI_NVME_IRQ_PIN_ENABLED 1
#define TRACE_PCI_NVME_IRQ_MASKED_ENABLED 1
#define TRACE_PCI_NVME_DMA_READ_ENABLED 1
#define TRACE_PCI_NVME_MAP_ADDR_ENABLED 1
#define TRACE_PCI_NVME_MAP_ADDR_CMB_ENABLED 1
#define TRACE_PCI_NVME_MAP_PRP_ENABLED 1
#define TRACE_PCI_NVME_MAP_SGL_ENABLED 1
#define TRACE_PCI_NVME_IO_CMD_ENABLED 1
#define TRACE_PCI_NVME_ADMIN_CMD_ENABLED 1
#define TRACE_PCI_NVME_READ_ENABLED 1
#define TRACE_PCI_NVME_WRITE_ENABLED 1
#define TRACE_PCI_NVME_RW_CB_ENABLED 1
#define TRACE_PCI_NVME_BLOCK_STATUS_ENABLED 1
#define TRACE_PCI_NVME_DSM_ENABLED 1
#define TRACE_PCI_NVME_DSM_DEALLOCATE_ENABLED 1
#define TRACE_PCI_NVME_COMPARE_ENABLED 1
#define TRACE_PCI_NVME_COMPARE_CB_ENABLED 1
#define TRACE_PCI_NVME_AIO_DISCARD_CB_ENABLED 1
#define TRACE_PCI_NVME_AIO_ZONE_RESET_CB_ENABLED 1
#define TRACE_PCI_NVME_CREATE_SQ_ENABLED 1
#define TRACE_PCI_NVME_CREATE_CQ_ENABLED 1
#define TRACE_PCI_NVME_DEL_SQ_ENABLED 1
#define TRACE_PCI_NVME_DEL_CQ_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_CTRL_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NS_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NS_CSI_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NSLIST_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_CMD_SET_ENABLED 1
#define TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_ENABLED 1
#define TRACE_PCI_NVME_GET_LOG_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_ENABLED 1
#define TRACE_PCI_NVME_SETFEAT_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_VWCACHE_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_NUMQ_ENABLED 1
#define TRACE_PCI_NVME_SETFEAT_NUMQ_ENABLED 1
#define TRACE_PCI_NVME_SETFEAT_TIMESTAMP_ENABLED 1
#define TRACE_PCI_NVME_GETFEAT_TIMESTAMP_ENABLED 1
#define TRACE_PCI_NVME_PROCESS_AERS_ENABLED 1
#define TRACE_PCI_NVME_AER_ENABLED 1
#define TRACE_PCI_NVME_AER_AERL_EXCEEDED_ENABLED 1
#define TRACE_PCI_NVME_AER_MASKED_ENABLED 1
#define TRACE_PCI_NVME_AER_POST_CQE_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_EVENT_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_ENABLED 1
#define TRACE_PCI_NVME_NO_OUTSTANDING_AERS_ENABLED 1
#define TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_ENABLED 1
#define TRACE_PCI_NVME_MMIO_READ_ENABLED 1
#define TRACE_PCI_NVME_MMIO_WRITE_ENABLED 1
#define TRACE_PCI_NVME_MMIO_DOORBELL_CQ_ENABLED 1
#define TRACE_PCI_NVME_MMIO_DOORBELL_SQ_ENABLED 1
#define TRACE_PCI_NVME_MMIO_INTM_SET_ENABLED 1
#define TRACE_PCI_NVME_MMIO_INTM_CLR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_CFG_ENABLED 1
#define TRACE_PCI_NVME_MMIO_AQATTR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ASQADDR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ACQADDR_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ASQADDR_HI_ENABLED 1
#define TRACE_PCI_NVME_MMIO_ACQADDR_HI_ENABLED 1
#define TRACE_PCI_NVME_MMIO_START_SUCCESS_ENABLED 1
#define TRACE_PCI_NVME_MMIO_STOPPED_ENABLED 1
#define TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_ENABLED 1
#define TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_ENABLED 1
#define TRACE_PCI_NVME_OPEN_ZONE_ENABLED 1
#define TRACE_PCI_NVME_CLOSE_ZONE_ENABLED 1
#define TRACE_PCI_NVME_FINISH_ZONE_ENABLED 1
#define TRACE_PCI_NVME_RESET_ZONE_ENABLED 1
#define TRACE_PCI_NVME_OFFLINE_ZONE_ENABLED 1
#define TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_ENABLED 1
#define TRACE_PCI_NVME_ZD_EXTENSION_SET_ENABLED 1
#define TRACE_PCI_NVME_CLEAR_NS_CLOSE_ENABLED 1
#define TRACE_PCI_NVME_CLEAR_NS_RESET_ENABLED 1
#define TRACE_PCI_NVME_ERR_MDTS_ENABLED 1
#define TRACE_PCI_NVME_ERR_REQ_STATUS_ENABLED 1
#define TRACE_PCI_NVME_ERR_ADDR_READ_ENABLED 1
#define TRACE_PCI_NVME_ERR_ADDR_WRITE_ENABLED 1
#define TRACE_PCI_NVME_ERR_CFS_ENABLED 1
#define TRACE_PCI_NVME_ERR_AIO_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_SGLD_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DMA_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_OPC_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_ENABLED 1
#define TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_ENABLED 1
#define TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_ENABLED 1
#define TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_ENABLED 1
#define TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_ENABLED 1
#define TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_IS_FULL_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_ENABLED 1
#define TRACE_PCI_NVME_ERR_APPEND_TOO_LARGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_ENABLED 1
#define TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_ENABLED 1
#define TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_IOCSCI_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_GETFEAT_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_SETFEAT_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_SQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_NBARASQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_NBARACQ_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_CSS_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_ENABLED 1
#define TRACE_PCI_NVME_ERR_STARTFAIL_ENABLED 1
#define TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIOWR_INVALID_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_ENABLED 1
#define TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_ENABLED 1
#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_ENABLED 1
#define TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_ENABLED 1
#define TRACE_XEN_BLOCK_REALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_CONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_DISCONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_SIZE_ENABLED 1
#define TRACE_XEN_DISK_REALIZE_ENABLED 1
#define TRACE_XEN_DISK_UNREALIZE_ENABLED 1
#define TRACE_XEN_CDROM_REALIZE_ENABLED 1
#define TRACE_XEN_CDROM_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_CREATE_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_DESTROY_ENABLED 1
#define TRACE_M25P80_FLASH_ERASE_ENABLED 1
#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_ENABLED 1
#define TRACE_M25P80_RESET_DONE_ENABLED 1
#define TRACE_M25P80_COMMAND_DECODED_ENABLED 1
#define TRACE_M25P80_COMPLETE_COLLECTING_ENABLED 1
#define TRACE_M25P80_POPULATED_JEDEC_ENABLED 1
#define TRACE_M25P80_CHIP_ERASE_ENABLED 1
#define TRACE_M25P80_SELECT_ENABLED 1
#define TRACE_M25P80_PAGE_PROGRAM_ENABLED 1
#define TRACE_M25P80_TRANSFER_ENABLED 1
#define TRACE_M25P80_READ_BYTE_ENABLED 1
#define TRACE_M25P80_READ_DATA_ENABLED 1
#define TRACE_M25P80_BINDING_ENABLED 1
#define TRACE_M25P80_BINDING_NO_BDRV_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_FDC_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 664 "trace/trace-hw_block.h"
        } else {
#line 4 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n", reg, value);
#line 668 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_read(reg, value);
    }
}

#define TRACE_FDC_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 695 "trace/trace-hw_block.h"
        } else {
#line 5 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n", reg, value);
#line 699 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_write(reg, value);
    }
}

#define TRACE_PFLASH_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_RESET) || \
    false)

static inline void _nocheck__trace_pflash_reset(void)
{
    if (trace_event_get_state(TRACE_PFLASH_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_reset " "reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 726 "trace/trace-hw_block.h"
        } else {
#line 9 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_reset " "reset" "\n");
#line 730 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_reset(void)
{
    if (true) {
        _nocheck__trace_pflash_reset();
    }
}

#define TRACE_PFLASH_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_pflash_timer_expired(uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_timer_expired " "command 0x%02x done" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd);
#line 757 "trace/trace-hw_block.h"
        } else {
#line 10 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_timer_expired " "command 0x%02x done" "\n", cmd);
#line 761 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_timer_expired(uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_timer_expired(cmd);
    }
}

#define TRACE_PFLASH_IO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_READ) || \
    false)

static inline void _nocheck__trace_pflash_io_read(uint64_t offset, unsigned size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_read " "offset:0x%04"PRIx64" size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size, value, cmd, wcycle);
#line 788 "trace/trace-hw_block.h"
        } else {
#line 11 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_io_read " "offset:0x%04"PRIx64" size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n", offset, size, value, cmd, wcycle);
#line 792 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_read(uint64_t offset, unsigned size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_read(offset, size, value, cmd, wcycle);
    }
}

#define TRACE_PFLASH_IO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_io_write(uint64_t offset, unsigned size, uint32_t value, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_write " "offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size, value, wcycle);
#line 819 "trace/trace-hw_block.h"
        } else {
#line 12 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_io_write " "offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n", offset, size, value, wcycle);
#line 823 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_write(uint64_t offset, unsigned size, uint32_t value, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_write(offset, size, value, wcycle);
    }
}

#define TRACE_PFLASH_DATA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_READ) || \
    false)

static inline void _nocheck__trace_pflash_data_read(uint64_t offset, unsigned size, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_read " "data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size, value);
#line 850 "trace/trace-hw_block.h"
        } else {
#line 13 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_data_read " "data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n", offset, size, value);
#line 854 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_read(uint64_t offset, unsigned size, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_data_read(offset, size, value);
    }
}

#define TRACE_PFLASH_DATA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_data_write(uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_write " "data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size, value, counter);
#line 881 "trace/trace-hw_block.h"
        } else {
#line 14 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_data_write " "data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n", offset, size, value, counter);
#line 885 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_write(uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (true) {
        _nocheck__trace_pflash_data_write(offset, size, value, counter);
    }
}

#define TRACE_PFLASH_MANUFACTURER_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_MANUFACTURER_ID) || \
    false)

static inline void _nocheck__trace_pflash_manufacturer_id(uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_MANUFACTURER_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_manufacturer_id " "Read Manufacturer ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 912 "trace/trace-hw_block.h"
        } else {
#line 15 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_manufacturer_id " "Read Manufacturer ID: 0x%04x" "\n", id);
#line 916 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_manufacturer_id(uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_manufacturer_id(id);
    }
}

#define TRACE_PFLASH_DEVICE_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_ID) || \
    false)

static inline void _nocheck__trace_pflash_device_id(uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_id " "Read Device ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 943 "trace/trace-hw_block.h"
        } else {
#line 16 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_device_id " "Read Device ID: 0x%04x" "\n", id);
#line 947 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_id(uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_device_id(id);
    }
}

#define TRACE_PFLASH_DEVICE_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_INFO) || \
    false)

static inline void _nocheck__trace_pflash_device_info(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_info " "Read Device Information offset:0x%04"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 974 "trace/trace-hw_block.h"
        } else {
#line 17 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pflash_device_info " "Read Device Information offset:0x%04"PRIx64 "\n", offset);
#line 978 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_info(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pflash_device_info(offset);
    }
}

#define TRACE_VIRTIO_BLK_REQ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_REQ_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_REQ_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_req_complete " "vdev %p req %p status %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, status);
#line 1005 "trace/trace-hw_block.h"
        } else {
#line 20 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("virtio_blk_req_complete " "vdev %p req %p status %d" "\n", vdev, req, status);
#line 1009 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (true) {
        _nocheck__trace_virtio_blk_req_complete(vdev, req, status);
    }
}

#define TRACE_VIRTIO_BLK_RW_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_RW_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_RW_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, ret);
#line 1036 "trace/trace-hw_block.h"
        } else {
#line 21 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n", vdev, req, ret);
#line 1040 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_rw_complete(vdev, req, ret);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1067 "trace/trace-hw_block.h"
        } else {
#line 22 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1071 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_write(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_READ) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1098 "trace/trace-hw_block.h"
        } else {
#line 23 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1102 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_read(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) || \
    false)

static inline void _nocheck__trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1129 "trace/trace-hw_block.h"
        } else {
#line 24 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n", vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1133 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (true) {
        _nocheck__trace_virtio_blk_submit_multireq(vdev, mrb, start, num_reqs, offset, size, is_write);
    }
}

#define TRACE_HD_GEOMETRY_LCHS_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_LCHS_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_LCHS_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs);
#line 1160 "trace/trace-hw_block.h"
        } else {
#line 27 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n", blk, cyls, heads, secs);
#line 1164 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (true) {
        _nocheck__trace_hd_geometry_lchs_guess(blk, cyls, heads, secs);
    }
}

#define TRACE_HD_GEOMETRY_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs, trans);
#line 1191 "trace/trace-hw_block.h"
        } else {
#line 28 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n", blk, cyls, heads, secs, trans);
#line 1195 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (true) {
        _nocheck__trace_hd_geometry_guess(blk, cyls, heads, secs, trans);
    }
}

#define TRACE_PCI_NVME_REGISTER_NAMESPACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_REGISTER_NAMESPACE) || \
    false)

static inline void _nocheck__trace_pci_nvme_register_namespace(uint32_t nsid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_REGISTER_NAMESPACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_register_namespace " "nsid %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nsid);
#line 1222 "trace/trace-hw_block.h"
        } else {
#line 32 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_register_namespace " "nsid %"PRIu32"" "\n", nsid);
#line 1226 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_register_namespace(uint32_t nsid)
{
    if (true) {
        _nocheck__trace_pci_nvme_register_namespace(nsid);
    }
}

#define TRACE_PCI_NVME_IRQ_MSIX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IRQ_MSIX) || \
    false)

static inline void _nocheck__trace_pci_nvme_irq_msix(uint32_t vector)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IRQ_MSIX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_irq_msix " "raising MSI-X IRQ vector %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 1253 "trace/trace-hw_block.h"
        } else {
#line 33 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_irq_msix " "raising MSI-X IRQ vector %u" "\n", vector);
#line 1257 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_irq_msix(uint32_t vector)
{
    if (true) {
        _nocheck__trace_pci_nvme_irq_msix(vector);
    }
}

#define TRACE_PCI_NVME_IRQ_PIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IRQ_PIN) || \
    false)

static inline void _nocheck__trace_pci_nvme_irq_pin(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IRQ_PIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_irq_pin " "pulsing IRQ pin" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1284 "trace/trace-hw_block.h"
        } else {
#line 34 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_irq_pin " "pulsing IRQ pin" "\n");
#line 1288 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_irq_pin(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_irq_pin();
    }
}

#define TRACE_PCI_NVME_IRQ_MASKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IRQ_MASKED) || \
    false)

static inline void _nocheck__trace_pci_nvme_irq_masked(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IRQ_MASKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_irq_masked " "IRQ is masked" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1315 "trace/trace-hw_block.h"
        } else {
#line 35 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_irq_masked " "IRQ is masked" "\n");
#line 1319 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_irq_masked(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_irq_masked();
    }
}

#define TRACE_PCI_NVME_DMA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DMA_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_dma_read(uint64_t prp1, uint64_t prp2)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DMA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dma_read " "DMA read, prp1=0x%"PRIx64" prp2=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prp1, prp2);
#line 1346 "trace/trace-hw_block.h"
        } else {
#line 36 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_dma_read " "DMA read, prp1=0x%"PRIx64" prp2=0x%"PRIx64"" "\n", prp1, prp2);
#line 1350 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_dma_read(uint64_t prp1, uint64_t prp2)
{
    if (true) {
        _nocheck__trace_pci_nvme_dma_read(prp1, prp2);
    }
}

#define TRACE_PCI_NVME_MAP_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_ADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_addr(uint64_t addr, uint64_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_addr " "addr 0x%"PRIx64" len %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, len);
#line 1377 "trace/trace-hw_block.h"
        } else {
#line 37 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_map_addr " "addr 0x%"PRIx64" len %"PRIu64"" "\n", addr, len);
#line 1381 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_map_addr(uint64_t addr, uint64_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_addr(addr, len);
    }
}

#define TRACE_PCI_NVME_MAP_ADDR_CMB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_ADDR_CMB) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_addr_cmb(uint64_t addr, uint64_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_ADDR_CMB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_addr_cmb " "addr 0x%"PRIx64" len %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, len);
#line 1408 "trace/trace-hw_block.h"
        } else {
#line 38 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_map_addr_cmb " "addr 0x%"PRIx64" len %"PRIu64"" "\n", addr, len);
#line 1412 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_map_addr_cmb(uint64_t addr, uint64_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_addr_cmb(addr, len);
    }
}

#define TRACE_PCI_NVME_MAP_PRP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_PRP) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_prp(uint64_t trans_len, uint32_t len, uint64_t prp1, uint64_t prp2, int num_prps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_PRP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_prp " "trans_len %"PRIu64" len %"PRIu32" prp1 0x%"PRIx64" prp2 0x%"PRIx64" num_prps %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , trans_len, len, prp1, prp2, num_prps);
#line 1439 "trace/trace-hw_block.h"
        } else {
#line 39 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_map_prp " "trans_len %"PRIu64" len %"PRIu32" prp1 0x%"PRIx64" prp2 0x%"PRIx64" num_prps %d" "\n", trans_len, len, prp1, prp2, num_prps);
#line 1443 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_map_prp(uint64_t trans_len, uint32_t len, uint64_t prp1, uint64_t prp2, int num_prps)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_prp(trans_len, len, prp1, prp2, num_prps);
    }
}

#define TRACE_PCI_NVME_MAP_SGL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MAP_SGL) || \
    false)

static inline void _nocheck__trace_pci_nvme_map_sgl(uint16_t cid, uint8_t typ, uint64_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MAP_SGL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_map_sgl " "cid %"PRIu16" type 0x%"PRIx8" len %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, typ, len);
#line 1470 "trace/trace-hw_block.h"
        } else {
#line 40 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_map_sgl " "cid %"PRIu16" type 0x%"PRIx8" len %"PRIu64"" "\n", cid, typ, len);
#line 1474 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_map_sgl(uint16_t cid, uint8_t typ, uint64_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_map_sgl(cid, typ, len);
    }
}

#define TRACE_PCI_NVME_IO_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IO_CMD) || \
    false)

static inline void _nocheck__trace_pci_nvme_io_cmd(uint16_t cid, uint32_t nsid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IO_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_io_cmd " "cid %"PRIu16" nsid %"PRIu32" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, sqid, opcode, opname);
#line 1501 "trace/trace-hw_block.h"
        } else {
#line 41 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_io_cmd " "cid %"PRIu16" nsid %"PRIu32" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n", cid, nsid, sqid, opcode, opname);
#line 1505 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_io_cmd(uint16_t cid, uint32_t nsid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (true) {
        _nocheck__trace_pci_nvme_io_cmd(cid, nsid, sqid, opcode, opname);
    }
}

#define TRACE_PCI_NVME_ADMIN_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ADMIN_CMD) || \
    false)

static inline void _nocheck__trace_pci_nvme_admin_cmd(uint16_t cid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ADMIN_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_admin_cmd " "cid %"PRIu16" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, sqid, opcode, opname);
#line 1532 "trace/trace-hw_block.h"
        } else {
#line 42 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_admin_cmd " "cid %"PRIu16" sqid %"PRIu16" opc 0x%"PRIx8" opname '%s'" "\n", cid, sqid, opcode, opname);
#line 1536 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_admin_cmd(uint16_t cid, uint16_t sqid, uint8_t opcode, const char * opname)
{
    if (true) {
        _nocheck__trace_pci_nvme_admin_cmd(cid, sqid, opcode, opname);
    }
}

#define TRACE_PCI_NVME_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_read(uint16_t cid, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_read " "cid %"PRIu16" nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, nlb, count, lba);
#line 1563 "trace/trace-hw_block.h"
        } else {
#line 43 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_read " "cid %"PRIu16" nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n", cid, nsid, nlb, count, lba);
#line 1567 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_read(uint16_t cid, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (true) {
        _nocheck__trace_pci_nvme_read(cid, nsid, nlb, count, lba);
    }
}

#define TRACE_PCI_NVME_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_write(uint16_t cid, const char * verb, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_write " "cid %"PRIu16" opname '%s' nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, verb, nsid, nlb, count, lba);
#line 1594 "trace/trace-hw_block.h"
        } else {
#line 44 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_write " "cid %"PRIu16" opname '%s' nsid %"PRIu32" nlb %"PRIu32" count %"PRIu64" lba 0x%"PRIx64"" "\n", cid, verb, nsid, nlb, count, lba);
#line 1598 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_write(uint16_t cid, const char * verb, uint32_t nsid, uint32_t nlb, uint64_t count, uint64_t lba)
{
    if (true) {
        _nocheck__trace_pci_nvme_write(cid, verb, nsid, nlb, count, lba);
    }
}

#define TRACE_PCI_NVME_RW_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_RW_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_rw_cb(uint16_t cid, const char * blkname)
{
    if (trace_event_get_state(TRACE_PCI_NVME_RW_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_rw_cb " "cid %"PRIu16" blk '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, blkname);
#line 1625 "trace/trace-hw_block.h"
        } else {
#line 45 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_rw_cb " "cid %"PRIu16" blk '%s'" "\n", cid, blkname);
#line 1629 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_rw_cb(uint16_t cid, const char * blkname)
{
    if (true) {
        _nocheck__trace_pci_nvme_rw_cb(cid, blkname);
    }
}

#define TRACE_PCI_NVME_BLOCK_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_BLOCK_STATUS) || \
    false)

static inline void _nocheck__trace_pci_nvme_block_status(int64_t offset, int64_t bytes, int64_t pnum, int ret, bool zeroed)
{
    if (trace_event_get_state(TRACE_PCI_NVME_BLOCK_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_block_status " "offset %"PRId64" bytes %"PRId64" pnum %"PRId64" ret 0x%x zeroed %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, bytes, pnum, ret, zeroed);
#line 1656 "trace/trace-hw_block.h"
        } else {
#line 46 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_block_status " "offset %"PRId64" bytes %"PRId64" pnum %"PRId64" ret 0x%x zeroed %d" "\n", offset, bytes, pnum, ret, zeroed);
#line 1660 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_block_status(int64_t offset, int64_t bytes, int64_t pnum, int ret, bool zeroed)
{
    if (true) {
        _nocheck__trace_pci_nvme_block_status(offset, bytes, pnum, ret, zeroed);
    }
}

#define TRACE_PCI_NVME_DSM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DSM) || \
    false)

static inline void _nocheck__trace_pci_nvme_dsm(uint16_t cid, uint32_t nsid, uint32_t nr, uint32_t attr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DSM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dsm " "cid %"PRIu16" nsid %"PRIu32" nr %"PRIu32" attr 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, nr, attr);
#line 1687 "trace/trace-hw_block.h"
        } else {
#line 47 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_dsm " "cid %"PRIu16" nsid %"PRIu32" nr %"PRIu32" attr 0x%"PRIx32"" "\n", cid, nsid, nr, attr);
#line 1691 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_dsm(uint16_t cid, uint32_t nsid, uint32_t nr, uint32_t attr)
{
    if (true) {
        _nocheck__trace_pci_nvme_dsm(cid, nsid, nr, attr);
    }
}

#define TRACE_PCI_NVME_DSM_DEALLOCATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DSM_DEALLOCATE) || \
    false)

static inline void _nocheck__trace_pci_nvme_dsm_deallocate(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DSM_DEALLOCATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_dsm_deallocate " "cid %"PRIu16" nsid %"PRIu32" slba %"PRIu64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, slba, nlb);
#line 1718 "trace/trace-hw_block.h"
        } else {
#line 48 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_dsm_deallocate " "cid %"PRIu16" nsid %"PRIu32" slba %"PRIu64" nlb %"PRIu32"" "\n", cid, nsid, slba, nlb);
#line 1722 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_dsm_deallocate(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_dsm_deallocate(cid, nsid, slba, nlb);
    }
}

#define TRACE_PCI_NVME_COMPARE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COMPARE) || \
    false)

static inline void _nocheck__trace_pci_nvme_compare(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COMPARE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_compare " "cid %"PRIu16" nsid %"PRIu32" slba 0x%"PRIx64" nlb %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, slba, nlb);
#line 1749 "trace/trace-hw_block.h"
        } else {
#line 49 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_compare " "cid %"PRIu16" nsid %"PRIu32" slba 0x%"PRIx64" nlb %"PRIu32"" "\n", cid, nsid, slba, nlb);
#line 1753 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_compare(uint16_t cid, uint32_t nsid, uint64_t slba, uint32_t nlb)
{
    if (true) {
        _nocheck__trace_pci_nvme_compare(cid, nsid, slba, nlb);
    }
}

#define TRACE_PCI_NVME_COMPARE_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_COMPARE_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_compare_cb(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_COMPARE_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_compare_cb " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 1780 "trace/trace-hw_block.h"
        } else {
#line 50 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_compare_cb " "cid %"PRIu16"" "\n", cid);
#line 1784 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_compare_cb(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_compare_cb(cid);
    }
}

#define TRACE_PCI_NVME_AIO_DISCARD_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AIO_DISCARD_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_aio_discard_cb(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AIO_DISCARD_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aio_discard_cb " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 1811 "trace/trace-hw_block.h"
        } else {
#line 51 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_aio_discard_cb " "cid %"PRIu16"" "\n", cid);
#line 1815 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_aio_discard_cb(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_aio_discard_cb(cid);
    }
}

#define TRACE_PCI_NVME_AIO_ZONE_RESET_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AIO_ZONE_RESET_CB) || \
    false)

static inline void _nocheck__trace_pci_nvme_aio_zone_reset_cb(uint16_t cid, uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AIO_ZONE_RESET_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aio_zone_reset_cb " "cid %"PRIu16" zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, zslba);
#line 1842 "trace/trace-hw_block.h"
        } else {
#line 52 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_aio_zone_reset_cb " "cid %"PRIu16" zslba 0x%"PRIx64"" "\n", cid, zslba);
#line 1846 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_aio_zone_reset_cb(uint16_t cid, uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_aio_zone_reset_cb(cid, zslba);
    }
}

#define TRACE_PCI_NVME_CREATE_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CREATE_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_create_sq(uint64_t addr, uint16_t sqid, uint16_t cqid, uint16_t qsize, uint16_t qflags)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CREATE_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_create_sq " "create submission queue, addr=0x%"PRIx64", sqid=%"PRIu16", cqid=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, sqid, cqid, qsize, qflags);
#line 1873 "trace/trace-hw_block.h"
        } else {
#line 53 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_create_sq " "create submission queue, addr=0x%"PRIx64", sqid=%"PRIu16", cqid=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16"" "\n", addr, sqid, cqid, qsize, qflags);
#line 1877 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_create_sq(uint64_t addr, uint16_t sqid, uint16_t cqid, uint16_t qsize, uint16_t qflags)
{
    if (true) {
        _nocheck__trace_pci_nvme_create_sq(addr, sqid, cqid, qsize, qflags);
    }
}

#define TRACE_PCI_NVME_CREATE_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CREATE_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_create_cq(uint64_t addr, uint16_t cqid, uint16_t vector, uint16_t size, uint16_t qflags, int ien)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CREATE_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_create_cq " "create completion queue, addr=0x%"PRIx64", cqid=%"PRIu16", vector=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16", ien=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, cqid, vector, size, qflags, ien);
#line 1904 "trace/trace-hw_block.h"
        } else {
#line 54 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_create_cq " "create completion queue, addr=0x%"PRIx64", cqid=%"PRIu16", vector=%"PRIu16", qsize=%"PRIu16", qflags=%"PRIu16", ien=%d" "\n", addr, cqid, vector, size, qflags, ien);
#line 1908 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_create_cq(uint64_t addr, uint16_t cqid, uint16_t vector, uint16_t size, uint16_t qflags, int ien)
{
    if (true) {
        _nocheck__trace_pci_nvme_create_cq(addr, cqid, vector, size, qflags, ien);
    }
}

#define TRACE_PCI_NVME_DEL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DEL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_del_sq(uint16_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DEL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_del_sq " "deleting submission queue sqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 1935 "trace/trace-hw_block.h"
        } else {
#line 55 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_del_sq " "deleting submission queue sqid=%"PRIu16"" "\n", qid);
#line 1939 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_del_sq(uint16_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_del_sq(qid);
    }
}

#define TRACE_PCI_NVME_DEL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_DEL_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_del_cq(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_DEL_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_del_cq " "deleted completion queue, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 1966 "trace/trace-hw_block.h"
        } else {
#line 56 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_del_cq " "deleted completion queue, cqid=%"PRIu16"" "\n", cqid);
#line 1970 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_del_cq(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_del_cq(cqid);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_CTRL) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ctrl(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ctrl " "identify controller" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1997 "trace/trace-hw_block.h"
        } else {
#line 57 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_ctrl " "identify controller" "\n");
#line 2001 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ctrl(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ctrl();
    }
}

#define TRACE_PCI_NVME_IDENTIFY_CTRL_CSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_CTRL_CSI) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ctrl_csi(uint8_t csi)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_CTRL_CSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ctrl_csi " "identify controller, csi=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , csi);
#line 2028 "trace/trace-hw_block.h"
        } else {
#line 58 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_ctrl_csi " "identify controller, csi=0x%"PRIx8"" "\n", csi);
#line 2032 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ctrl_csi(uint8_t csi)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ctrl_csi(csi);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NS) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ns(uint32_t ns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ns " "nsid %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns);
#line 2059 "trace/trace-hw_block.h"
        } else {
#line 59 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_ns " "nsid %"PRIu32"" "\n", ns);
#line 2063 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ns(uint32_t ns)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ns(ns);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NS_CSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NS_CSI) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ns_csi(uint32_t ns, uint8_t csi)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NS_CSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ns_csi " "nsid=%"PRIu32", csi=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns, csi);
#line 2090 "trace/trace-hw_block.h"
        } else {
#line 60 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_ns_csi " "nsid=%"PRIu32", csi=0x%"PRIx8"" "\n", ns, csi);
#line 2094 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ns_csi(uint32_t ns, uint8_t csi)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ns_csi(ns, csi);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NSLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NSLIST) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_nslist(uint32_t ns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NSLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_nslist " "nsid %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns);
#line 2121 "trace/trace-hw_block.h"
        } else {
#line 61 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_nslist " "nsid %"PRIu32"" "\n", ns);
#line 2125 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_nslist(uint32_t ns)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_nslist(ns);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_nslist_csi(uint16_t ns, uint8_t csi)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NSLIST_CSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_nslist_csi " "nsid=%"PRIu16", csi=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns, csi);
#line 2152 "trace/trace-hw_block.h"
        } else {
#line 62 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_nslist_csi " "nsid=%"PRIu16", csi=0x%"PRIx8"" "\n", ns, csi);
#line 2156 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_nslist_csi(uint16_t ns, uint8_t csi)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_nslist_csi(ns, csi);
    }
}

#define TRACE_PCI_NVME_IDENTIFY_CMD_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_CMD_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_cmd_set(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_CMD_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_cmd_set " "identify i/o command set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2183 "trace/trace-hw_block.h"
        } else {
#line 63 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_cmd_set " "identify i/o command set" "\n");
#line 2187 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_cmd_set(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_cmd_set();
    }
}

#define TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST) || \
    false)

static inline void _nocheck__trace_pci_nvme_identify_ns_descr_list(uint32_t ns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_IDENTIFY_NS_DESCR_LIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_identify_ns_descr_list " "nsid %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ns);
#line 2214 "trace/trace-hw_block.h"
        } else {
#line 64 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_identify_ns_descr_list " "nsid %"PRIu32"" "\n", ns);
#line 2218 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_identify_ns_descr_list(uint32_t ns)
{
    if (true) {
        _nocheck__trace_pci_nvme_identify_ns_descr_list(ns);
    }
}

#define TRACE_PCI_NVME_GET_LOG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GET_LOG) || \
    false)

static inline void _nocheck__trace_pci_nvme_get_log(uint16_t cid, uint8_t lid, uint8_t lsp, uint8_t rae, uint32_t len, uint64_t off)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GET_LOG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_get_log " "cid %"PRIu16" lid 0x%"PRIx8" lsp 0x%"PRIx8" rae 0x%"PRIx8" len %"PRIu32" off %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, lid, lsp, rae, len, off);
#line 2245 "trace/trace-hw_block.h"
        } else {
#line 65 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_get_log " "cid %"PRIu16" lid 0x%"PRIx8" lsp 0x%"PRIx8" rae 0x%"PRIx8" len %"PRIu32" off %"PRIu64"" "\n", cid, lid, lsp, rae, len, off);
#line 2249 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_get_log(uint16_t cid, uint8_t lid, uint8_t lsp, uint8_t rae, uint32_t len, uint64_t off)
{
    if (true) {
        _nocheck__trace_pci_nvme_get_log(cid, lid, lsp, rae, len, off);
    }
}

#define TRACE_PCI_NVME_GETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t sel, uint32_t cdw11)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" sel 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, fid, sel, cdw11);
#line 2276 "trace/trace-hw_block.h"
        } else {
#line 66 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_getfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" sel 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n", cid, nsid, fid, sel, cdw11);
#line 2280 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t sel, uint32_t cdw11)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat(cid, nsid, fid, sel, cdw11);
    }
}

#define TRACE_PCI_NVME_SETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_setfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t save, uint32_t cdw11)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_setfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" save 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, fid, save, cdw11);
#line 2307 "trace/trace-hw_block.h"
        } else {
#line 67 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_setfeat " "cid %"PRIu16" nsid 0x%"PRIx32" fid 0x%"PRIx8" save 0x%"PRIx8" cdw11 0x%"PRIx32"" "\n", cid, nsid, fid, save, cdw11);
#line 2311 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_setfeat(uint16_t cid, uint32_t nsid, uint8_t fid, uint8_t save, uint32_t cdw11)
{
    if (true) {
        _nocheck__trace_pci_nvme_setfeat(cid, nsid, fid, save, cdw11);
    }
}

#define TRACE_PCI_NVME_GETFEAT_VWCACHE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT_VWCACHE) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat_vwcache(const char* result)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT_VWCACHE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat_vwcache " "get feature volatile write cache, result=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , result);
#line 2338 "trace/trace-hw_block.h"
        } else {
#line 68 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_getfeat_vwcache " "get feature volatile write cache, result=%s" "\n", result);
#line 2342 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat_vwcache(const char* result)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat_vwcache(result);
    }
}

#define TRACE_PCI_NVME_GETFEAT_NUMQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT_NUMQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat_numq(int result)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT_NUMQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat_numq " "get feature number of queues, result=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , result);
#line 2369 "trace/trace-hw_block.h"
        } else {
#line 69 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_getfeat_numq " "get feature number of queues, result=%d" "\n", result);
#line 2373 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat_numq(int result)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat_numq(result);
    }
}

#define TRACE_PCI_NVME_SETFEAT_NUMQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SETFEAT_NUMQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_setfeat_numq(int reqcq, int reqsq, int gotcq, int gotsq)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SETFEAT_NUMQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_setfeat_numq " "requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reqcq, reqsq, gotcq, gotsq);
#line 2400 "trace/trace-hw_block.h"
        } else {
#line 70 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_setfeat_numq " "requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d" "\n", reqcq, reqsq, gotcq, gotsq);
#line 2404 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_setfeat_numq(int reqcq, int reqsq, int gotcq, int gotsq)
{
    if (true) {
        _nocheck__trace_pci_nvme_setfeat_numq(reqcq, reqsq, gotcq, gotsq);
    }
}

#define TRACE_PCI_NVME_SETFEAT_TIMESTAMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SETFEAT_TIMESTAMP) || \
    false)

static inline void _nocheck__trace_pci_nvme_setfeat_timestamp(uint64_t ts)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SETFEAT_TIMESTAMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_setfeat_timestamp " "set feature timestamp = 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ts);
#line 2431 "trace/trace-hw_block.h"
        } else {
#line 71 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_setfeat_timestamp " "set feature timestamp = 0x%"PRIx64"" "\n", ts);
#line 2435 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_setfeat_timestamp(uint64_t ts)
{
    if (true) {
        _nocheck__trace_pci_nvme_setfeat_timestamp(ts);
    }
}

#define TRACE_PCI_NVME_GETFEAT_TIMESTAMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_GETFEAT_TIMESTAMP) || \
    false)

static inline void _nocheck__trace_pci_nvme_getfeat_timestamp(uint64_t ts)
{
    if (trace_event_get_state(TRACE_PCI_NVME_GETFEAT_TIMESTAMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_getfeat_timestamp " "get feature timestamp = 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ts);
#line 2462 "trace/trace-hw_block.h"
        } else {
#line 72 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_getfeat_timestamp " "get feature timestamp = 0x%"PRIx64"" "\n", ts);
#line 2466 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_getfeat_timestamp(uint64_t ts)
{
    if (true) {
        _nocheck__trace_pci_nvme_getfeat_timestamp(ts);
    }
}

#define TRACE_PCI_NVME_PROCESS_AERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_PROCESS_AERS) || \
    false)

static inline void _nocheck__trace_pci_nvme_process_aers(int queued)
{
    if (trace_event_get_state(TRACE_PCI_NVME_PROCESS_AERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_process_aers " "queued %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , queued);
#line 2493 "trace/trace-hw_block.h"
        } else {
#line 73 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_process_aers " "queued %d" "\n", queued);
#line 2497 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_process_aers(int queued)
{
    if (true) {
        _nocheck__trace_pci_nvme_process_aers(queued);
    }
}

#define TRACE_PCI_NVME_AER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 2524 "trace/trace-hw_block.h"
        } else {
#line 74 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_aer " "cid %"PRIu16"" "\n", cid);
#line 2528 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_aer(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer(cid);
    }
}

#define TRACE_PCI_NVME_AER_AERL_EXCEEDED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER_AERL_EXCEEDED) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer_aerl_exceeded(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER_AERL_EXCEEDED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer_aerl_exceeded " "aerl exceeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2555 "trace/trace-hw_block.h"
        } else {
#line 75 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_aer_aerl_exceeded " "aerl exceeded" "\n");
#line 2559 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_aer_aerl_exceeded(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer_aerl_exceeded();
    }
}

#define TRACE_PCI_NVME_AER_MASKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER_MASKED) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer_masked(uint8_t type, uint8_t mask)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER_MASKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer_masked " "type 0x%"PRIx8" mask 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, mask);
#line 2586 "trace/trace-hw_block.h"
        } else {
#line 76 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_aer_masked " "type 0x%"PRIx8" mask 0x%"PRIx8"" "\n", type, mask);
#line 2590 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_aer_masked(uint8_t type, uint8_t mask)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer_masked(type, mask);
    }
}

#define TRACE_PCI_NVME_AER_POST_CQE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_AER_POST_CQE) || \
    false)

static inline void _nocheck__trace_pci_nvme_aer_post_cqe(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (trace_event_get_state(TRACE_PCI_NVME_AER_POST_CQE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_aer_post_cqe " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , typ, info, log_page);
#line 2617 "trace/trace-hw_block.h"
        } else {
#line 77 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_aer_post_cqe " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n", typ, info, log_page);
#line 2621 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_aer_post_cqe(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (true) {
        _nocheck__trace_pci_nvme_aer_post_cqe(typ, info, log_page);
    }
}

#define TRACE_PCI_NVME_ENQUEUE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_EVENT) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_event(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_event " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , typ, info, log_page);
#line 2648 "trace/trace-hw_block.h"
        } else {
#line 78 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_enqueue_event " "type 0x%"PRIx8" info 0x%"PRIx8" lid 0x%"PRIx8"" "\n", typ, info, log_page);
#line 2652 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_event(uint8_t typ, uint8_t info, uint8_t log_page)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_event(typ, info, log_page);
    }
}

#define TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_event_noqueue(int queued)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_EVENT_NOQUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_event_noqueue " "queued %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , queued);
#line 2679 "trace/trace-hw_block.h"
        } else {
#line 79 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_enqueue_event_noqueue " "queued %d" "\n", queued);
#line 2683 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_event_noqueue(int queued)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_event_noqueue(queued);
    }
}

#define TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_event_masked(uint8_t typ)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_EVENT_MASKED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_event_masked " "type 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , typ);
#line 2710 "trace/trace-hw_block.h"
        } else {
#line 80 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_enqueue_event_masked " "type 0x%"PRIx8"" "\n", typ);
#line 2714 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_event_masked(uint8_t typ)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_event_masked(typ);
    }
}

#define TRACE_PCI_NVME_NO_OUTSTANDING_AERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_NO_OUTSTANDING_AERS) || \
    false)

static inline void _nocheck__trace_pci_nvme_no_outstanding_aers(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_NO_OUTSTANDING_AERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_no_outstanding_aers " "ignoring event; no outstanding AERs" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2741 "trace/trace-hw_block.h"
        } else {
#line 81 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_no_outstanding_aers " "ignoring event; no outstanding AERs" "\n");
#line 2745 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_no_outstanding_aers(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_no_outstanding_aers();
    }
}

#define TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION) || \
    false)

static inline void _nocheck__trace_pci_nvme_enqueue_req_completion(uint16_t cid, uint16_t cqid, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ENQUEUE_REQ_COMPLETION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_enqueue_req_completion " "cid %"PRIu16" cqid %"PRIu16" status 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, cqid, status);
#line 2772 "trace/trace-hw_block.h"
        } else {
#line 82 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_enqueue_req_completion " "cid %"PRIu16" cqid %"PRIu16" status 0x%"PRIx16"" "\n", cid, cqid, status);
#line 2776 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_enqueue_req_completion(uint16_t cid, uint16_t cqid, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_enqueue_req_completion(cid, cqid, status);
    }
}

#define TRACE_PCI_NVME_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_read(uint64_t addr, unsigned size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_read " "addr 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, size);
#line 2803 "trace/trace-hw_block.h"
        } else {
#line 83 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_read " "addr 0x%"PRIx64" size %d" "\n", addr, size);
#line 2807 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_read(uint64_t addr, unsigned size)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_read(addr, size);
    }
}

#define TRACE_PCI_NVME_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_write(uint64_t addr, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_write " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, size);
#line 2834 "trace/trace-hw_block.h"
        } else {
#line 84 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_write " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n", addr, data, size);
#line 2838 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_write(uint64_t addr, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_write(addr, data, size);
    }
}

#define TRACE_PCI_NVME_MMIO_DOORBELL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_DOORBELL_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_doorbell_cq(uint16_t cqid, uint16_t new_head)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_DOORBELL_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_doorbell_cq " "cqid %"PRIu16" new_head %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid, new_head);
#line 2865 "trace/trace-hw_block.h"
        } else {
#line 85 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_doorbell_cq " "cqid %"PRIu16" new_head %"PRIu16"" "\n", cqid, new_head);
#line 2869 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_doorbell_cq(uint16_t cqid, uint16_t new_head)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_doorbell_cq(cqid, new_head);
    }
}

#define TRACE_PCI_NVME_MMIO_DOORBELL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_DOORBELL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_doorbell_sq(uint16_t sqid, uint16_t new_tail)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_DOORBELL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_doorbell_sq " "sqid %"PRIu16" new_tail %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sqid, new_tail);
#line 2896 "trace/trace-hw_block.h"
        } else {
#line 86 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_doorbell_sq " "sqid %"PRIu16" new_tail %"PRIu16"" "\n", sqid, new_tail);
#line 2900 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_doorbell_sq(uint16_t sqid, uint16_t new_tail)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_doorbell_sq(sqid, new_tail);
    }
}

#define TRACE_PCI_NVME_MMIO_INTM_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_INTM_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_intm_set(uint64_t data, uint64_t new_mask)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_INTM_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_intm_set " "wrote MMIO, interrupt mask set, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_mask);
#line 2927 "trace/trace-hw_block.h"
        } else {
#line 87 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_intm_set " "wrote MMIO, interrupt mask set, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n", data, new_mask);
#line 2931 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_intm_set(uint64_t data, uint64_t new_mask)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_intm_set(data, new_mask);
    }
}

#define TRACE_PCI_NVME_MMIO_INTM_CLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_INTM_CLR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_intm_clr(uint64_t data, uint64_t new_mask)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_INTM_CLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_intm_clr " "wrote MMIO, interrupt mask clr, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_mask);
#line 2958 "trace/trace-hw_block.h"
        } else {
#line 88 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_intm_clr " "wrote MMIO, interrupt mask clr, data=0x%"PRIx64", new_mask=0x%"PRIx64"" "\n", data, new_mask);
#line 2962 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_intm_clr(uint64_t data, uint64_t new_mask)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_intm_clr(data, new_mask);
    }
}

#define TRACE_PCI_NVME_MMIO_CFG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_CFG) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_cfg(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_CFG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_cfg " "wrote MMIO, config controller config=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 2989 "trace/trace-hw_block.h"
        } else {
#line 89 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_cfg " "wrote MMIO, config controller config=0x%"PRIx64"" "\n", data);
#line 2993 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_cfg(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_cfg(data);
    }
}

#define TRACE_PCI_NVME_MMIO_AQATTR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_AQATTR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_aqattr(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_AQATTR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_aqattr " "wrote MMIO, admin queue attributes=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3020 "trace/trace-hw_block.h"
        } else {
#line 90 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_aqattr " "wrote MMIO, admin queue attributes=0x%"PRIx64"" "\n", data);
#line 3024 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_aqattr(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_aqattr(data);
    }
}

#define TRACE_PCI_NVME_MMIO_ASQADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ASQADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_asqaddr(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ASQADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_asqaddr " "wrote MMIO, admin submission queue address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3051 "trace/trace-hw_block.h"
        } else {
#line 91 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_asqaddr " "wrote MMIO, admin submission queue address=0x%"PRIx64"" "\n", data);
#line 3055 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_asqaddr(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_asqaddr(data);
    }
}

#define TRACE_PCI_NVME_MMIO_ACQADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ACQADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_acqaddr(uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ACQADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_acqaddr " "wrote MMIO, admin completion queue address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 3082 "trace/trace-hw_block.h"
        } else {
#line 92 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_acqaddr " "wrote MMIO, admin completion queue address=0x%"PRIx64"" "\n", data);
#line 3086 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_acqaddr(uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_acqaddr(data);
    }
}

#define TRACE_PCI_NVME_MMIO_ASQADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ASQADDR_HI) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_asqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ASQADDR_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_asqaddr_hi " "wrote MMIO, admin submission queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_addr);
#line 3113 "trace/trace-hw_block.h"
        } else {
#line 93 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_asqaddr_hi " "wrote MMIO, admin submission queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n", data, new_addr);
#line 3117 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_asqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_asqaddr_hi(data, new_addr);
    }
}

#define TRACE_PCI_NVME_MMIO_ACQADDR_HI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_ACQADDR_HI) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_acqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_ACQADDR_HI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_acqaddr_hi " "wrote MMIO, admin completion queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data, new_addr);
#line 3144 "trace/trace-hw_block.h"
        } else {
#line 94 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_acqaddr_hi " "wrote MMIO, admin completion queue high half=0x%"PRIx64", new_address=0x%"PRIx64"" "\n", data, new_addr);
#line 3148 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_acqaddr_hi(uint64_t data, uint64_t new_addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_acqaddr_hi(data, new_addr);
    }
}

#define TRACE_PCI_NVME_MMIO_START_SUCCESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_START_SUCCESS) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_start_success(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_START_SUCCESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_start_success " "setting controller enable bit succeeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3175 "trace/trace-hw_block.h"
        } else {
#line 95 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_start_success " "setting controller enable bit succeeded" "\n");
#line 3179 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_start_success(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_start_success();
    }
}

#define TRACE_PCI_NVME_MMIO_STOPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_STOPPED) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_stopped(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_STOPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_stopped " "cleared controller enable bit" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3206 "trace/trace-hw_block.h"
        } else {
#line 96 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_stopped " "cleared controller enable bit" "\n");
#line 3210 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_stopped(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_stopped();
    }
}

#define TRACE_PCI_NVME_MMIO_SHUTDOWN_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_SHUTDOWN_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_shutdown_set(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_SHUTDOWN_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_shutdown_set " "shutdown bit set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3237 "trace/trace-hw_block.h"
        } else {
#line 97 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_shutdown_set " "shutdown bit set" "\n");
#line 3241 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_shutdown_set(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_shutdown_set();
    }
}

#define TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED) || \
    false)

static inline void _nocheck__trace_pci_nvme_mmio_shutdown_cleared(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_MMIO_SHUTDOWN_CLEARED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_mmio_shutdown_cleared " "shutdown bit cleared" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3268 "trace/trace-hw_block.h"
        } else {
#line 98 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_mmio_shutdown_cleared " "shutdown bit cleared" "\n");
#line 3272 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_mmio_shutdown_cleared(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_mmio_shutdown_cleared();
    }
}

#define TRACE_PCI_NVME_OPEN_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_OPEN_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_open_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_OPEN_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_open_zone " "open zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3299 "trace/trace-hw_block.h"
        } else {
#line 99 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_open_zone " "open zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3303 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_open_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_open_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_CLOSE_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CLOSE_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_close_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CLOSE_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_close_zone " "close zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3330 "trace/trace-hw_block.h"
        } else {
#line 100 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_close_zone " "close zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3334 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_close_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_close_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_FINISH_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_FINISH_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_finish_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_FINISH_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_finish_zone " "finish zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3361 "trace/trace-hw_block.h"
        } else {
#line 101 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_finish_zone " "finish zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3365 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_finish_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_finish_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_RESET_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_RESET_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_reset_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_RESET_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_reset_zone " "reset zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3392 "trace/trace-hw_block.h"
        } else {
#line 102 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_reset_zone " "reset zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3396 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_reset_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_reset_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_OFFLINE_ZONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_OFFLINE_ZONE) || \
    false)

static inline void _nocheck__trace_pci_nvme_offline_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (trace_event_get_state(TRACE_PCI_NVME_OFFLINE_ZONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_offline_zone " "offline zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx, all);
#line 3423 "trace/trace-hw_block.h"
        } else {
#line 103 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_offline_zone " "offline zone, slba=%"PRIu64", idx=%"PRIu32", all=%"PRIi32"" "\n", slba, zone_idx, all);
#line 3427 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_offline_zone(uint64_t slba, uint32_t zone_idx, int all)
{
    if (true) {
        _nocheck__trace_pci_nvme_offline_zone(slba, zone_idx, all);
    }
}

#define TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION) || \
    false)

static inline void _nocheck__trace_pci_nvme_set_descriptor_extension(uint64_t slba, uint32_t zone_idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_SET_DESCRIPTOR_EXTENSION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_set_descriptor_extension " "set zone descriptor extension, slba=%"PRIu64", idx=%"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone_idx);
#line 3454 "trace/trace-hw_block.h"
        } else {
#line 104 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_set_descriptor_extension " "set zone descriptor extension, slba=%"PRIu64", idx=%"PRIu32"" "\n", slba, zone_idx);
#line 3458 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_set_descriptor_extension(uint64_t slba, uint32_t zone_idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_set_descriptor_extension(slba, zone_idx);
    }
}

#define TRACE_PCI_NVME_ZD_EXTENSION_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ZD_EXTENSION_SET) || \
    false)

static inline void _nocheck__trace_pci_nvme_zd_extension_set(uint32_t zone_idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ZD_EXTENSION_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_zd_extension_set " "set descriptor extension for zone_idx=%"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zone_idx);
#line 3485 "trace/trace-hw_block.h"
        } else {
#line 105 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_zd_extension_set " "set descriptor extension for zone_idx=%"PRIu32"" "\n", zone_idx);
#line 3489 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_zd_extension_set(uint32_t zone_idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_zd_extension_set(zone_idx);
    }
}

#define TRACE_PCI_NVME_CLEAR_NS_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CLEAR_NS_CLOSE) || \
    false)

static inline void _nocheck__trace_pci_nvme_clear_ns_close(uint32_t state, uint64_t slba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CLEAR_NS_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_clear_ns_close " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Closed state" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, slba);
#line 3516 "trace/trace-hw_block.h"
        } else {
#line 106 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_clear_ns_close " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Closed state" "\n", state, slba);
#line 3520 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_clear_ns_close(uint32_t state, uint64_t slba)
{
    if (true) {
        _nocheck__trace_pci_nvme_clear_ns_close(state, slba);
    }
}

#define TRACE_PCI_NVME_CLEAR_NS_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_CLEAR_NS_RESET) || \
    false)

static inline void _nocheck__trace_pci_nvme_clear_ns_reset(uint32_t state, uint64_t slba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_CLEAR_NS_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_clear_ns_reset " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Empty state" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, slba);
#line 3547 "trace/trace-hw_block.h"
        } else {
#line 107 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_clear_ns_reset " "zone state=%"PRIu32", slba=%"PRIu64" transitioned to Empty state" "\n", state, slba);
#line 3551 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_clear_ns_reset(uint32_t state, uint64_t slba)
{
    if (true) {
        _nocheck__trace_pci_nvme_clear_ns_reset(state, slba);
    }
}

#define TRACE_PCI_NVME_ERR_MDTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_MDTS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_mdts(uint16_t cid, size_t len)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_MDTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_mdts " "cid %"PRIu16" len %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, len);
#line 3578 "trace/trace-hw_block.h"
        } else {
#line 110 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_mdts " "cid %"PRIu16" len %zu" "\n", cid, len);
#line 3582 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_mdts(uint16_t cid, size_t len)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_mdts(cid, len);
    }
}

#define TRACE_PCI_NVME_ERR_REQ_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_REQ_STATUS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_req_status(uint16_t cid, uint32_t nsid, uint16_t status, uint8_t opc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_REQ_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_req_status " "cid %"PRIu16" nsid %"PRIu32" status 0x%"PRIx16" opc 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, nsid, status, opc);
#line 3609 "trace/trace-hw_block.h"
        } else {
#line 111 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_req_status " "cid %"PRIu16" nsid %"PRIu32" status 0x%"PRIx16" opc 0x%"PRIx8"" "\n", cid, nsid, status, opc);
#line 3613 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_req_status(uint16_t cid, uint32_t nsid, uint16_t status, uint8_t opc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_req_status(cid, nsid, status, opc);
    }
}

#define TRACE_PCI_NVME_ERR_ADDR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ADDR_READ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_addr_read(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ADDR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_addr_read " "addr 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 3640 "trace/trace-hw_block.h"
        } else {
#line 112 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_addr_read " "addr 0x%"PRIx64"" "\n", addr);
#line 3644 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_addr_read(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_addr_read(addr);
    }
}

#define TRACE_PCI_NVME_ERR_ADDR_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ADDR_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_addr_write(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ADDR_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_addr_write " "addr 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 3671 "trace/trace-hw_block.h"
        } else {
#line 113 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_addr_write " "addr 0x%"PRIx64"" "\n", addr);
#line 3675 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_addr_write(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_addr_write(addr);
    }
}

#define TRACE_PCI_NVME_ERR_CFS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_CFS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_cfs(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_CFS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_cfs " "controller fatal status" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3702 "trace/trace-hw_block.h"
        } else {
#line 114 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_cfs " "controller fatal status" "\n");
#line 3706 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_cfs(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_cfs();
    }
}

#define TRACE_PCI_NVME_ERR_AIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_AIO) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_aio(uint16_t cid, const char * errname, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_AIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_aio " "cid %"PRIu16" err '%s' status 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, errname, status);
#line 3733 "trace/trace-hw_block.h"
        } else {
#line 115 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_aio " "cid %"PRIu16" err '%s' status 0x%"PRIx16"" "\n", cid, errname, status);
#line 3737 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_aio(uint16_t cid, const char * errname, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_aio(cid, errname, status);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_SGLD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_SGLD) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_sgld(uint16_t cid, uint8_t typ)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_SGLD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, typ);
#line 3764 "trace/trace-hw_block.h"
        } else {
#line 116 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n", cid, typ);
#line 3768 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_sgld(uint16_t cid, uint8_t typ)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_sgld(cid, typ);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_num_sgld(uint16_t cid, uint8_t typ)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_NUM_SGLD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_num_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, typ);
#line 3795 "trace/trace-hw_block.h"
        } else {
#line 117 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_num_sgld " "cid %"PRIu16" type 0x%"PRIx8"" "\n", cid, typ);
#line 3799 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_num_sgld(uint16_t cid, uint8_t typ)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_num_sgld(cid, typ);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_sgl_excess_length(uint16_t cid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_SGL_EXCESS_LENGTH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_sgl_excess_length " "cid %"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid);
#line 3826 "trace/trace-hw_block.h"
        } else {
#line 118 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_sgl_excess_length " "cid %"PRIu16"" "\n", cid);
#line 3830 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_sgl_excess_length(uint16_t cid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_sgl_excess_length(cid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DMA) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_dma(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DMA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_dma " "PRP/SGL is too small for transfer size" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3857 "trace/trace-hw_block.h"
        } else {
#line 119 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_dma " "PRP/SGL is too small for transfer size" "\n");
#line 3861 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_dma(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_dma();
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_prplist_ent(uint64_t prplist)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_PRPLIST_ENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_prplist_ent " "PRP list entry is not page aligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prplist);
#line 3888 "trace/trace-hw_block.h"
        } else {
#line 120 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_prplist_ent " "PRP list entry is not page aligned: 0x%"PRIx64"" "\n", prplist);
#line 3892 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_prplist_ent(uint64_t prplist)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_prplist_ent(prplist);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_prp2_align(uint64_t prp2)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_PRP2_ALIGN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 121 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_prp2_align " "PRP2 is not page aligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , prp2);
#line 3919 "trace/trace-hw_block.h"
        } else {
#line 121 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_prp2_align " "PRP2 is not page aligned: 0x%"PRIx64"" "\n", prp2);
#line 3923 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_prp2_align(uint64_t prp2)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_prp2_align(prp2);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_OPC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_OPC) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_opc(uint8_t opc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_OPC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_opc " "invalid opcode 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opc);
#line 3950 "trace/trace-hw_block.h"
        } else {
#line 122 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_opc " "invalid opcode 0x%"PRIx8"" "\n", opc);
#line 3954 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_opc(uint8_t opc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_opc(opc);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_admin_opc(uint8_t opc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_ADMIN_OPC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_admin_opc " "invalid admin opcode 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opc);
#line 3981 "trace/trace-hw_block.h"
        } else {
#line 123 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_admin_opc " "invalid admin opcode 0x%"PRIx8"" "\n", opc);
#line 3985 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_admin_opc(uint8_t opc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_admin_opc(opc);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_lba_range(uint64_t start, uint64_t len, uint64_t limit)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_LBA_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_lba_range " "Invalid LBA start=%"PRIu64" len=%"PRIu64" limit=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start, len, limit);
#line 4012 "trace/trace-hw_block.h"
        } else {
#line 124 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_lba_range " "Invalid LBA start=%"PRIu64" len=%"PRIu64" limit=%"PRIu64"" "\n", start, len, limit);
#line 4016 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_lba_range(uint64_t start, uint64_t len, uint64_t limit)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_lba_range(start, len, limit);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_log_page_offset(uint64_t ofs, uint64_t size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_log_page_offset " "must be <= %"PRIu64", got %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ofs, size);
#line 4043 "trace/trace-hw_block.h"
        } else {
#line 125 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_log_page_offset " "must be <= %"PRIu64", got %"PRIu64"" "\n", ofs, size);
#line 4047 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_log_page_offset(uint64_t ofs, uint64_t size)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_log_page_offset(ofs, size);
    }
}

#define TRACE_PCI_NVME_ERR_CMB_INVALID_CBA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_CMB_INVALID_CBA) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_cmb_invalid_cba(uint64_t cmbmsc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_CMB_INVALID_CBA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_cmb_invalid_cba " "cmbmsc 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmbmsc);
#line 4074 "trace/trace-hw_block.h"
        } else {
#line 126 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_cmb_invalid_cba " "cmbmsc 0x%"PRIx64"" "\n", cmbmsc);
#line 4078 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_cmb_invalid_cba(uint64_t cmbmsc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_cmb_invalid_cba(cmbmsc);
    }
}

#define TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_cmb_not_enabled(uint64_t cmbmsc)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_CMB_NOT_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_cmb_not_enabled " "cmbmsc 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmbmsc);
#line 4105 "trace/trace-hw_block.h"
        } else {
#line 127 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_cmb_not_enabled " "cmbmsc 0x%"PRIx64"" "\n", cmbmsc);
#line 4109 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_cmb_not_enabled(uint64_t cmbmsc)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_cmb_not_enabled(cmbmsc);
    }
}

#define TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_unaligned_zone_cmd(uint8_t action, uint64_t slba, uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_UNALIGNED_ZONE_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_unaligned_zone_cmd " "unaligned zone op 0x%"PRIx32", got slba=%"PRIu64", zslba=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action, slba, zslba);
#line 4136 "trace/trace-hw_block.h"
        } else {
#line 128 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_unaligned_zone_cmd " "unaligned zone op 0x%"PRIx32", got slba=%"PRIu64", zslba=%"PRIu64"" "\n", action, slba, zslba);
#line 4140 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_unaligned_zone_cmd(uint8_t action, uint64_t slba, uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_unaligned_zone_cmd(action, slba, zslba);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_zone_state_transition(uint8_t action, uint64_t slba, uint8_t attrs)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_ZONE_STATE_TRANSITION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_zone_state_transition " "action=0x%"PRIx8", slba=%"PRIu64", attrs=0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action, slba, attrs);
#line 4167 "trace/trace-hw_block.h"
        } else {
#line 129 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_zone_state_transition " "action=0x%"PRIx8", slba=%"PRIu64", attrs=0x%"PRIx32"" "\n", action, slba, attrs);
#line 4171 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_zone_state_transition(uint8_t action, uint64_t slba, uint8_t attrs)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_zone_state_transition(action, slba, attrs);
    }
}

#define TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_write_not_at_wp(uint64_t slba, uint64_t zone, uint64_t wp)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_WRITE_NOT_AT_WP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_write_not_at_wp " "writing at slba=%"PRIu64", zone=%"PRIu64", but wp=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone, wp);
#line 4198 "trace/trace-hw_block.h"
        } else {
#line 130 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_write_not_at_wp " "writing at slba=%"PRIu64", zone=%"PRIu64", but wp=%"PRIu64"" "\n", slba, zone, wp);
#line 4202 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_write_not_at_wp(uint64_t slba, uint64_t zone, uint64_t wp)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_write_not_at_wp(slba, zone, wp);
    }
}

#define TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_append_not_at_start(uint64_t slba, uint64_t zone)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_APPEND_NOT_AT_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_append_not_at_start " "appending at slba=%"PRIu64", but zone=%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, zone);
#line 4229 "trace/trace-hw_block.h"
        } else {
#line 131 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_append_not_at_start " "appending at slba=%"PRIu64", but zone=%"PRIu64"" "\n", slba, zone);
#line 4233 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_append_not_at_start(uint64_t slba, uint64_t zone)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_append_not_at_start(slba, zone);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_IS_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_IS_FULL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_is_full(uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_IS_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_is_full " "zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba);
#line 4260 "trace/trace-hw_block.h"
        } else {
#line 132 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zone_is_full " "zslba 0x%"PRIx64"" "\n", zslba);
#line 4264 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_is_full(uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_is_full(zslba);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_is_read_only(uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_IS_READ_ONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_is_read_only " "zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba);
#line 4291 "trace/trace-hw_block.h"
        } else {
#line 133 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zone_is_read_only " "zslba 0x%"PRIx64"" "\n", zslba);
#line 4295 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_is_read_only(uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_is_read_only(zslba);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_is_offline(uint64_t zslba)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_IS_OFFLINE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 134 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_is_offline " "zslba 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zslba);
#line 4322 "trace/trace-hw_block.h"
        } else {
#line 134 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zone_is_offline " "zslba 0x%"PRIx64"" "\n", zslba);
#line 4326 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_is_offline(uint64_t zslba)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_is_offline(zslba);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_BOUNDARY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_BOUNDARY) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_boundary(uint64_t slba, uint32_t nlb, uint64_t zcap)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_BOUNDARY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 135 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_boundary " "lba 0x%"PRIx64" nlb %"PRIu32" zcap 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb, zcap);
#line 4353 "trace/trace-hw_block.h"
        } else {
#line 135 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zone_boundary " "lba 0x%"PRIx64" nlb %"PRIu32" zcap 0x%"PRIx64"" "\n", slba, nlb, zcap);
#line 4357 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_boundary(uint64_t slba, uint32_t nlb, uint64_t zcap)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_boundary(slba, nlb, zcap);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_invalid_write(uint64_t slba, uint64_t wp)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_INVALID_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_invalid_write " "lba 0x%"PRIx64" wp 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, wp);
#line 4384 "trace/trace-hw_block.h"
        } else {
#line 136 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zone_invalid_write " "lba 0x%"PRIx64" wp 0x%"PRIx64"" "\n", slba, wp);
#line 4388 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_invalid_write(uint64_t slba, uint64_t wp)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_invalid_write(slba, wp);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_write_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_WRITE_NOT_OK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_write_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb, status);
#line 4415 "trace/trace-hw_block.h"
        } else {
#line 137 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zone_write_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n", slba, nlb, status);
#line 4419 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_write_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_write_not_ok(slba, nlb, status);
    }
}

#define TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zone_read_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZONE_READ_NOT_OK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zone_read_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb, status);
#line 4446 "trace/trace-hw_block.h"
        } else {
#line 138 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zone_read_not_ok " "slba=%"PRIu64", nlb=%"PRIu32", status=0x%"PRIx16"" "\n", slba, nlb, status);
#line 4450 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zone_read_not_ok(uint64_t slba, uint32_t nlb, uint16_t status)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zone_read_not_ok(slba, nlb, status);
    }
}

#define TRACE_PCI_NVME_ERR_APPEND_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_APPEND_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_append_too_large(uint64_t slba, uint32_t nlb, uint8_t zasl)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_APPEND_TOO_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_append_too_large " "slba=%"PRIu64", nlb=%"PRIu32", zasl=%"PRIu8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slba, nlb, zasl);
#line 4477 "trace/trace-hw_block.h"
        } else {
#line 139 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_append_too_large " "slba=%"PRIu64", nlb=%"PRIu32", zasl=%"PRIu8"" "\n", slba, nlb, zasl);
#line 4481 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_append_too_large(uint64_t slba, uint32_t nlb, uint8_t zasl)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_append_too_large(slba, nlb, zasl);
    }
}

#define TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_insuff_active_res(uint32_t max_active)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INSUFF_ACTIVE_RES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_insuff_active_res " "max_active=%"PRIu32" zone limit exceeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , max_active);
#line 4508 "trace/trace-hw_block.h"
        } else {
#line 140 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_insuff_active_res " "max_active=%"PRIu32" zone limit exceeded" "\n", max_active);
#line 4512 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_insuff_active_res(uint32_t max_active)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_insuff_active_res(max_active);
    }
}

#define TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_insuff_open_res(uint32_t max_open)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INSUFF_OPEN_RES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_insuff_open_res " "max_open=%"PRIu32" zone limit exceeded" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , max_open);
#line 4539 "trace/trace-hw_block.h"
        } else {
#line 141 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_insuff_open_res " "max_open=%"PRIu32" zone limit exceeded" "\n", max_open);
#line 4543 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_insuff_open_res(uint32_t max_open)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_insuff_open_res(max_open);
    }
}

#define TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_zd_extension_map_error(uint32_t zone_idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_ZD_EXTENSION_MAP_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 142 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_zd_extension_map_error " "can't map descriptor extension for zone_idx=%"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zone_idx);
#line 4570 "trace/trace-hw_block.h"
        } else {
#line 142 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_zd_extension_map_error " "can't map descriptor extension for zone_idx=%"PRIu32"" "\n", zone_idx);
#line 4574 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_zd_extension_map_error(uint32_t zone_idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_zd_extension_map_error(zone_idx);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_IOCSCI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_IOCSCI) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_iocsci(uint32_t idx)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_IOCSCI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_iocsci " "unsupported command set combination index %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx);
#line 4601 "trace/trace-hw_block.h"
        } else {
#line 143 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_iocsci " "unsupported command set combination index %"PRIu32"" "\n", idx);
#line 4605 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_iocsci(uint32_t idx)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_iocsci(idx);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DEL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DEL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_del_sq(uint16_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DEL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_del_sq " "invalid submission queue deletion, sid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 4632 "trace/trace-hw_block.h"
        } else {
#line 144 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_del_sq " "invalid submission queue deletion, sid=%"PRIu16"" "\n", qid);
#line 4636 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_del_sq(uint16_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_del_sq(qid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_CQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 145 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_cqid " "failed creating submission queue, invalid cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 4663 "trace/trace-hw_block.h"
        } else {
#line 145 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_cqid " "failed creating submission queue, invalid cqid=%"PRIu16"" "\n", cqid);
#line 4667 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_cqid(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_sqid(uint16_t sqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 146 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_sqid " "failed creating submission queue, invalid sqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sqid);
#line 4694 "trace/trace-hw_block.h"
        } else {
#line 146 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_sqid " "failed creating submission queue, invalid sqid=%"PRIu16"" "\n", sqid);
#line 4698 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_sqid(uint16_t sqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_sqid(sqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_size(uint16_t qsize)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_size " "failed creating submission queue, invalid qsize=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qsize);
#line 4725 "trace/trace-hw_block.h"
        } else {
#line 147 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_size " "failed creating submission queue, invalid qsize=%"PRIu16"" "\n", qsize);
#line 4729 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_size(uint16_t qsize)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_size(qsize);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_addr(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_addr " "failed creating submission queue, addr=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4756 "trace/trace-hw_block.h"
        } else {
#line 148 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_addr " "failed creating submission queue, addr=0x%"PRIx64"" "\n", addr);
#line 4760 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_addr(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_addr(addr);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_sq_qflags(uint16_t qflags)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_SQ_QFLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 149 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_qflags " "failed creating submission queue, qflags=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qflags);
#line 4787 "trace/trace-hw_block.h"
        } else {
#line 149 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_sq_qflags " "failed creating submission queue, qflags=%"PRIu16"" "\n", qflags);
#line 4791 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_sq_qflags(uint16_t qflags)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_sq_qflags(qflags);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_del_cq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_CQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 150 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_cqid " "failed deleting completion queue, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 4818 "trace/trace-hw_block.h"
        } else {
#line 150 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_del_cq_cqid " "failed deleting completion queue, cqid=%"PRIu16"" "\n", cqid);
#line 4822 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_del_cq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_del_cq_cqid(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_del_cq_notempty(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_DEL_CQ_NOTEMPTY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 151 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_notempty " "failed deleting completion queue, it is not empty, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 4849 "trace/trace-hw_block.h"
        } else {
#line 151 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_del_cq_notempty " "failed deleting completion queue, it is not empty, cqid=%"PRIu16"" "\n", cqid);
#line 4853 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_del_cq_notempty(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_del_cq_notempty(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_cqid(uint16_t cqid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_CQID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 152 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_cqid " "failed creating completion queue, cqid=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cqid);
#line 4880 "trace/trace-hw_block.h"
        } else {
#line 152 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_cqid " "failed creating completion queue, cqid=%"PRIu16"" "\n", cqid);
#line 4884 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_cqid(uint16_t cqid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_cqid(cqid);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_size(uint16_t size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_size " "failed creating completion queue, size=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 4911 "trace/trace-hw_block.h"
        } else {
#line 153 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_size " "failed creating completion queue, size=%"PRIu16"" "\n", size);
#line 4915 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_size(uint16_t size)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_size(size);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_addr(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_addr " "failed creating completion queue, addr=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4942 "trace/trace-hw_block.h"
        } else {
#line 154 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_addr " "failed creating completion queue, addr=0x%"PRIx64"" "\n", addr);
#line 4946 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_addr(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_addr(addr);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_vector(uint16_t vector)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_VECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 155 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_vector " "failed creating completion queue, vector=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 4973 "trace/trace-hw_block.h"
        } else {
#line 155 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_vector " "failed creating completion queue, vector=%"PRIu16"" "\n", vector);
#line 4977 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_vector(uint16_t vector)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_vector(vector);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_create_cq_qflags(uint16_t qflags)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_CREATE_CQ_QFLAGS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 156 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_qflags " "failed creating completion queue, qflags=%"PRIu16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qflags);
#line 5004 "trace/trace-hw_block.h"
        } else {
#line 156 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_create_cq_qflags " "failed creating completion queue, qflags=%"PRIu16"" "\n", qflags);
#line 5008 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_create_cq_qflags(uint16_t qflags)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_create_cq_qflags(qflags);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_identify_cns(uint16_t cns)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_IDENTIFY_CNS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 157 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_identify_cns " "identify, invalid cns=0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cns);
#line 5035 "trace/trace-hw_block.h"
        } else {
#line 157 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_identify_cns " "identify, invalid cns=0x%"PRIx16"" "\n", cns);
#line 5039 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_identify_cns(uint16_t cns)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_identify_cns(cns);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_GETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_GETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_getfeat(int dw10)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_GETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_getfeat " "invalid get features, dw10=0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dw10);
#line 5066 "trace/trace-hw_block.h"
        } else {
#line 158 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_getfeat " "invalid get features, dw10=0x%"PRIx32"" "\n", dw10);
#line 5070 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_getfeat(int dw10)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_getfeat(dw10);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_SETFEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_SETFEAT) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_setfeat(uint32_t dw10)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_SETFEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_setfeat " "invalid set features, dw10=0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dw10);
#line 5097 "trace/trace-hw_block.h"
        } else {
#line 159 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_setfeat " "invalid set features, dw10=0x%"PRIx32"" "\n", dw10);
#line 5101 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_setfeat(uint32_t dw10)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_setfeat(dw10);
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_log_page(uint16_t cid, uint16_t lid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_LOG_PAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 160 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_log_page " "cid %"PRIu16" lid 0x%"PRIx16"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cid, lid);
#line 5128 "trace/trace-hw_block.h"
        } else {
#line 160 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_log_page " "cid %"PRIu16" lid 0x%"PRIx16"" "\n", cid, lid);
#line 5132 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_log_page(uint16_t cid, uint16_t lid)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_log_page(cid, lid);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_cq(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 161 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_cq " "nvme_start_ctrl failed because there are non-admin completion queues" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5159 "trace/trace-hw_block.h"
        } else {
#line 161 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_cq " "nvme_start_ctrl failed because there are non-admin completion queues" "\n");
#line 5163 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_cq(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_cq();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_sq(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 162 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_sq " "nvme_start_ctrl failed because there are non-admin submission queues" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5190 "trace/trace-hw_block.h"
        } else {
#line 162 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_sq " "nvme_start_ctrl failed because there are non-admin submission queues" "\n");
#line 5194 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_sq(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_sq();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_NBARASQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_NBARASQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_nbarasq(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_NBARASQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 163 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_nbarasq " "nvme_start_ctrl failed because the admin submission queue address is null" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5221 "trace/trace-hw_block.h"
        } else {
#line 163 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_nbarasq " "nvme_start_ctrl failed because the admin submission queue address is null" "\n");
#line 5225 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_nbarasq(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_nbarasq();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_NBARACQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_NBARACQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_nbaracq(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_NBARACQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 164 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_nbaracq " "nvme_start_ctrl failed because the admin completion queue address is null" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5252 "trace/trace-hw_block.h"
        } else {
#line 164 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_nbaracq " "nvme_start_ctrl failed because the admin completion queue address is null" "\n");
#line 5256 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_nbaracq(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_nbaracq();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_asq_misaligned(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ASQ_MISALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 165 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_asq_misaligned " "nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 5283 "trace/trace-hw_block.h"
        } else {
#line 165 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_asq_misaligned " "nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%"PRIx64"" "\n", addr);
#line 5287 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_asq_misaligned(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_asq_misaligned(addr);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_acq_misaligned(uint64_t addr)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ACQ_MISALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 166 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_acq_misaligned " "nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 5314 "trace/trace-hw_block.h"
        } else {
#line 166 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_acq_misaligned " "nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%"PRIx64"" "\n", addr);
#line 5318 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_acq_misaligned(uint64_t addr)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_acq_misaligned(addr);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_page_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 167 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_page_too_small " "nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5345 "trace/trace-hw_block.h"
        } else {
#line 167 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_page_too_small " "nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u" "\n", log2ps, maxlog2ps);
#line 5349 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_page_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_page_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_page_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_PAGE_TOO_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 168 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_page_too_large " "nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5376 "trace/trace-hw_block.h"
        } else {
#line 168 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_page_too_large " "nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u" "\n", log2ps, maxlog2ps);
#line 5380 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_page_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_page_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_cqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 169 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_cqent_too_small " "nvme_start_ctrl failed because the completion queue entry size is too small: log2size=%u, min=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5407 "trace/trace-hw_block.h"
        } else {
#line 169 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_cqent_too_small " "nvme_start_ctrl failed because the completion queue entry size is too small: log2size=%u, min=%u" "\n", log2ps, maxlog2ps);
#line 5411 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_cqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_cqent_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_cqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CQENT_TOO_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 170 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_cqent_too_large " "nvme_start_ctrl failed because the completion queue entry size is too large: log2size=%u, max=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5438 "trace/trace-hw_block.h"
        } else {
#line 170 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_cqent_too_large " "nvme_start_ctrl failed because the completion queue entry size is too large: log2size=%u, max=%u" "\n", log2ps, maxlog2ps);
#line 5442 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_cqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_cqent_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_sqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 171 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_sqent_too_small " "nvme_start_ctrl failed because the submission queue entry size is too small: log2size=%u, min=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5469 "trace/trace-hw_block.h"
        } else {
#line 171 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_sqent_too_small " "nvme_start_ctrl failed because the submission queue entry size is too small: log2size=%u, min=%u" "\n", log2ps, maxlog2ps);
#line 5473 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_sqent_too_small(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_sqent_too_small(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_sqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_SQENT_TOO_LARGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 172 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_sqent_too_large " "nvme_start_ctrl failed because the submission queue entry size is too large: log2size=%u, max=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , log2ps, maxlog2ps);
#line 5500 "trace/trace-hw_block.h"
        } else {
#line 172 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_sqent_too_large " "nvme_start_ctrl failed because the submission queue entry size is too large: log2size=%u, max=%u" "\n", log2ps, maxlog2ps);
#line 5504 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_sqent_too_large(uint8_t log2ps, uint8_t maxlog2ps)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_sqent_too_large(log2ps, maxlog2ps);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_CSS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_CSS) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_css(uint8_t css)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_CSS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 173 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_css " "nvme_start_ctrl failed because invalid command set selected:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , css);
#line 5531 "trace/trace-hw_block.h"
        } else {
#line 173 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_css " "nvme_start_ctrl failed because invalid command set selected:%u" "\n", css);
#line 5535 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_css(uint8_t css)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_css(css);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_asqent_sz_zero(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ASQENT_SZ_ZERO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 174 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_asqent_sz_zero " "nvme_start_ctrl failed because the admin submission queue size is zero" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5562 "trace/trace-hw_block.h"
        } else {
#line 174 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_asqent_sz_zero " "nvme_start_ctrl failed because the admin submission queue size is zero" "\n");
#line 5566 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_asqent_sz_zero(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_asqent_sz_zero();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_acqent_sz_zero(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ACQENT_SZ_ZERO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 175 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_acqent_sz_zero " "nvme_start_ctrl failed because the admin completion queue size is zero" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5593 "trace/trace-hw_block.h"
        } else {
#line 175 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_acqent_sz_zero " "nvme_start_ctrl failed because the admin completion queue size is zero" "\n");
#line 5597 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_acqent_sz_zero(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_acqent_sz_zero();
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail_zasl_too_small(uint32_t zasl, uint32_t pagesz)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL_ZASL_TOO_SMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 176 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail_zasl_too_small " "nvme_start_ctrl failed because zone append size limit %"PRIu32" is too small, needs to be >= %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , zasl, pagesz);
#line 5624 "trace/trace-hw_block.h"
        } else {
#line 176 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail_zasl_too_small " "nvme_start_ctrl failed because zone append size limit %"PRIu32" is too small, needs to be >= %"PRIu32"" "\n", zasl, pagesz);
#line 5628 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail_zasl_too_small(uint32_t zasl, uint32_t pagesz)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail_zasl_too_small(zasl, pagesz);
    }
}

#define TRACE_PCI_NVME_ERR_STARTFAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_STARTFAIL) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_startfail(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_STARTFAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 177 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_startfail " "setting controller enable bit failed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5655 "trace/trace-hw_block.h"
        } else {
#line 177 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_startfail " "setting controller enable bit failed" "\n");
#line 5659 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_startfail(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_startfail();
    }
}

#define TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION) || \
    false)

static inline void _nocheck__trace_pci_nvme_err_invalid_mgmt_action(uint8_t action)
{
    if (trace_event_get_state(TRACE_PCI_NVME_ERR_INVALID_MGMT_ACTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 178 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_err_invalid_mgmt_action " "action=0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , action);
#line 5686 "trace/trace-hw_block.h"
        } else {
#line 178 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_err_invalid_mgmt_action " "action=0x%"PRIx8"" "\n", action);
#line 5690 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_err_invalid_mgmt_action(uint8_t action)
{
    if (true) {
        _nocheck__trace_pci_nvme_err_invalid_mgmt_action(action);
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_misaligned32(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_MISALIGNED32) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 181 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_misaligned32 " "MMIO write not 32-bit aligned, offset=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 5717 "trace/trace-hw_block.h"
        } else {
#line 181 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_misaligned32 " "MMIO write not 32-bit aligned, offset=0x%"PRIx64"" "\n", offset);
#line 5721 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_misaligned32(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_misaligned32(offset);
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_toosmall(uint64_t offset, unsigned size)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_TOOSMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 182 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_toosmall " "MMIO write smaller than 32 bits, offset=0x%"PRIx64", size=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, size);
#line 5748 "trace/trace-hw_block.h"
        } else {
#line 182 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_toosmall " "MMIO write smaller than 32 bits, offset=0x%"PRIx64", size=%u" "\n", offset, size);
#line 5752 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_toosmall(uint64_t offset, unsigned size)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_toosmall(offset, size);
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_intmask_with_msix(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_INTMASK_WITH_MSIX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 183 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_intmask_with_msix " "undefined access to interrupt mask set when MSI-X is enabled" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5779 "trace/trace-hw_block.h"
        } else {
#line 183 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_intmask_with_msix " "undefined access to interrupt mask set when MSI-X is enabled" "\n");
#line 5783 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_intmask_with_msix(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_intmask_with_msix();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_ro_csts(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_RO_CSTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 184 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_ro_csts " "attempted to set a read only bit of controller status" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5810 "trace/trace-hw_block.h"
        } else {
#line 184 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_ro_csts " "attempted to set a read only bit of controller status" "\n");
#line 5814 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_ro_csts(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_ro_csts();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_W1C_UNSUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 185 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_w1c_unsupported " "attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5841 "trace/trace-hw_block.h"
        } else {
#line 185 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_ssreset_w1c_unsupported " "attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)" "\n");
#line 5845 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_w1c_unsupported();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_unsupported(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_SSRESET_UNSUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 186 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_unsupported " "attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5872 "trace/trace-hw_block.h"
        } else {
#line 186 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_ssreset_unsupported " "attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)" "\n");
#line 5876 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_ssreset_unsupported(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_ssreset_unsupported();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_cmbloc_reserved(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_CMBLOC_RESERVED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 187 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbloc_reserved " "invalid write to reserved CMBLOC when CMBSZ is zero, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5903 "trace/trace-hw_block.h"
        } else {
#line 187 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_cmbloc_reserved " "invalid write to reserved CMBLOC when CMBSZ is zero, ignored" "\n");
#line 5907 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_cmbloc_reserved(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_cmbloc_reserved();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_cmbsz_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_CMBSZ_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 188 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbsz_readonly " "invalid write to read only CMBSZ, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5934 "trace/trace-hw_block.h"
        } else {
#line 188 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_cmbsz_readonly " "invalid write to read only CMBSZ, ignored" "\n");
#line 5938 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_cmbsz_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_cmbsz_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrcap_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMRCAP_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 189 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrcap_readonly " "invalid write to read only PMRCAP, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5965 "trace/trace-hw_block.h"
        } else {
#line 189 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrcap_readonly " "invalid write to read only PMRCAP, ignored" "\n");
#line 5969 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrcap_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrcap_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrsts_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMRSTS_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 190 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrsts_readonly " "invalid write to read only PMRSTS, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5996 "trace/trace-hw_block.h"
        } else {
#line 190 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrsts_readonly " "invalid write to read only PMRSTS, ignored" "\n");
#line 6000 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrsts_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrsts_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrebs_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMREBS_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 191 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrebs_readonly " "invalid write to read only PMREBS, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6027 "trace/trace-hw_block.h"
        } else {
#line 191 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrebs_readonly " "invalid write to read only PMREBS, ignored" "\n");
#line 6031 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrebs_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrebs_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_pmrswtp_readonly(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_PMRSWTP_READONLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 192 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrswtp_readonly " "invalid write to read only PMRSWTP, ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6058 "trace/trace-hw_block.h"
        } else {
#line 192 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_pmrswtp_readonly " "invalid write to read only PMRSWTP, ignored" "\n");
#line 6062 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_pmrswtp_readonly(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_pmrswtp_readonly();
    }
}

#define TRACE_PCI_NVME_UB_MMIOWR_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIOWR_INVALID) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiowr_invalid(uint64_t offset, uint64_t data)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIOWR_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 193 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiowr_invalid " "invalid MMIO write, offset=0x%"PRIx64", data=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data);
#line 6089 "trace/trace-hw_block.h"
        } else {
#line 193 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiowr_invalid " "invalid MMIO write, offset=0x%"PRIx64", data=0x%"PRIx64"" "\n", offset, data);
#line 6093 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiowr_invalid(uint64_t offset, uint64_t data)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiowr_invalid(offset, data);
    }
}

#define TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiord_misaligned32(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIORD_MISALIGNED32) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 194 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiord_misaligned32 " "MMIO read not 32-bit aligned, offset=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6120 "trace/trace-hw_block.h"
        } else {
#line 194 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiord_misaligned32 " "MMIO read not 32-bit aligned, offset=0x%"PRIx64"" "\n", offset);
#line 6124 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiord_misaligned32(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiord_misaligned32(offset);
    }
}

#define TRACE_PCI_NVME_UB_MMIORD_TOOSMALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIORD_TOOSMALL) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiord_toosmall(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIORD_TOOSMALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 195 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiord_toosmall " "MMIO read smaller than 32-bits, offset=0x%"PRIx64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6151 "trace/trace-hw_block.h"
        } else {
#line 195 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiord_toosmall " "MMIO read smaller than 32-bits, offset=0x%"PRIx64"" "\n", offset);
#line 6155 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiord_toosmall(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiord_toosmall(offset);
    }
}

#define TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_mmiord_invalid_ofs(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_MMIORD_INVALID_OFS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 196 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_mmiord_invalid_ofs " "MMIO read beyond last register, offset=0x%"PRIx64", returning 0" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6182 "trace/trace-hw_block.h"
        } else {
#line 196 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_mmiord_invalid_ofs " "MMIO read beyond last register, offset=0x%"PRIx64", returning 0" "\n", offset);
#line 6186 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_mmiord_invalid_ofs(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_mmiord_invalid_ofs(offset);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_MISALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_MISALIGNED) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_misaligned(uint64_t offset)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_MISALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 197 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_misaligned " "doorbell write not 32-bit aligned, offset=0x%"PRIx64", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 6213 "trace/trace-hw_block.h"
        } else {
#line 197 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_db_wr_misaligned " "doorbell write not 32-bit aligned, offset=0x%"PRIx64", ignoring" "\n", offset);
#line 6217 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_misaligned(uint64_t offset)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_misaligned(offset);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_cq(uint32_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 198 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cq " "completion queue doorbell write for nonexistent queue, cqid=%"PRIu32", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 6244 "trace/trace-hw_block.h"
        } else {
#line 198 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_cq " "completion queue doorbell write for nonexistent queue, cqid=%"PRIu32", ignoring" "\n", qid);
#line 6248 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_cq(uint32_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_cq(qid);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_cqhead(uint32_t qid, uint16_t new_head)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_CQHEAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 199 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cqhead " "completion queue doorbell write value beyond queue size, cqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, new_head);
#line 6275 "trace/trace-hw_block.h"
        } else {
#line 199 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_cqhead " "completion queue doorbell write value beyond queue size, cqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n", qid, new_head);
#line 6279 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_cqhead(uint32_t qid, uint16_t new_head)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_cqhead(qid, new_head);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_sq(uint32_t qid)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 200 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sq " "submission queue doorbell write for nonexistent queue, sqid=%"PRIu32", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 6306 "trace/trace-hw_block.h"
        } else {
#line 200 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_sq " "submission queue doorbell write for nonexistent queue, sqid=%"PRIu32", ignoring" "\n", qid);
#line 6310 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_sq(uint32_t qid)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_sq(qid);
    }
}

#define TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_db_wr_invalid_sqtail(uint32_t qid, uint16_t new_tail)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_DB_WR_INVALID_SQTAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 201 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sqtail " "submission queue doorbell write value beyond queue size, sqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, new_tail);
#line 6337 "trace/trace-hw_block.h"
        } else {
#line 201 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_db_wr_invalid_sqtail " "submission queue doorbell write value beyond queue size, sqid=%"PRIu32", new_head=%"PRIu16", ignoring" "\n", qid, new_tail);
#line 6341 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_db_wr_invalid_sqtail(uint32_t qid, uint16_t new_tail)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_db_wr_invalid_sqtail(qid, new_tail);
    }
}

#define TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE) || \
    false)

static inline void _nocheck__trace_pci_nvme_ub_unknown_css_value(void)
{
    if (trace_event_get_state(TRACE_PCI_NVME_UB_UNKNOWN_CSS_VALUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 202 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pci_nvme_ub_unknown_css_value " "unknown value in cc.css field" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6368 "trace/trace-hw_block.h"
        } else {
#line 202 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("pci_nvme_ub_unknown_css_value " "unknown value in cc.css field" "\n");
#line 6372 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pci_nvme_ub_unknown_css_value(void)
{
    if (true) {
        _nocheck__trace_pci_nvme_ub_unknown_css_value();
    }
}

#define TRACE_XEN_BLOCK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 205 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_realize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 6399 "trace/trace-hw_block.h"
        } else {
#line 205 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_realize " "%s d%up%u" "\n", type, disk, partition);
#line 6403 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_realize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_CONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_CONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 206 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_connect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 6430 "trace/trace-hw_block.h"
        } else {
#line 206 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_connect " "%s d%up%u" "\n", type, disk, partition);
#line 6434 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_connect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DISCONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 207 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_disconnect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 6461 "trace/trace-hw_block.h"
        } else {
#line 207 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_disconnect " "%s d%up%u" "\n", type, disk, partition);
#line 6465 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_disconnect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 208 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_unrealize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 6492 "trace/trace-hw_block.h"
        } else {
#line 208 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_unrealize " "%s d%up%u" "\n", type, disk, partition);
#line 6496 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_unrealize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_SIZE) || \
    false)

static inline void _nocheck__trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 209 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_size " "%s d%up%u %"PRIi64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition, sectors);
#line 6523 "trace/trace-hw_block.h"
        } else {
#line 209 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_size " "%s d%up%u %"PRIi64 "\n", type, disk, partition, sectors);
#line 6527 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (true) {
        _nocheck__trace_xen_block_size(type, disk, partition, sectors);
    }
}

#define TRACE_XEN_DISK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 210 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6554 "trace/trace-hw_block.h"
        } else {
#line 210 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_disk_realize " "" "\n");
#line 6558 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_realize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_realize();
    }
}

#define TRACE_XEN_DISK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 211 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6585 "trace/trace-hw_block.h"
        } else {
#line 211 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_disk_unrealize " "" "\n");
#line 6589 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_unrealize();
    }
}

#define TRACE_XEN_CDROM_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 212 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6616 "trace/trace-hw_block.h"
        } else {
#line 212 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_cdrom_realize " "" "\n");
#line 6620 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_realize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_realize();
    }
}

#define TRACE_XEN_CDROM_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 213 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6647 "trace/trace-hw_block.h"
        } else {
#line 213 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_cdrom_unrealize " "" "\n");
#line 6651 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_unrealize();
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_ADD) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_add(char * str)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 214 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_add " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 6678 "trace/trace-hw_block.h"
        } else {
#line 214 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_blockdev_add " "%s" "\n", str);
#line 6682 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_add(char * str)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_add(str);
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_DEL) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_del(const char * node_name)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 215 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_del " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node_name);
#line 6709 "trace/trace-hw_block.h"
        } else {
#line 215 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_blockdev_del " "%s" "\n", node_name);
#line 6713 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_del(const char * node_name)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_del(node_name);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_CREATE) || \
    false)

static inline void _nocheck__trace_xen_block_device_create(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 216 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_create " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 6740 "trace/trace-hw_block.h"
        } else {
#line 216 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_device_create " "%u" "\n", number);
#line 6744 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_create(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_create(number);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_block_device_destroy(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 217 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_destroy " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 6771 "trace/trace-hw_block.h"
        } else {
#line 217 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("xen_block_device_destroy " "%u" "\n", number);
#line 6775 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_destroy(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_destroy(number);
    }
}

#define TRACE_M25P80_FLASH_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_FLASH_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (trace_event_get_state(TRACE_M25P80_FLASH_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 220 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, len);
#line 6802 "trace/trace-hw_block.h"
        } else {
#line 220 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n", s, offset, len);
#line 6806 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (true) {
        _nocheck__trace_m25p80_flash_erase(s, offset, len);
    }
}

#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) || \
    false)

static inline void _nocheck__trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (trace_event_get_state(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 221 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, prev, data);
#line 6833 "trace/trace-hw_block.h"
        } else {
#line 221 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n", s, addr, prev, data);
#line 6837 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (true) {
        _nocheck__trace_m25p80_programming_zero_to_one(s, addr, prev, data);
    }
}

#define TRACE_M25P80_RESET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_RESET_DONE) || \
    false)

static inline void _nocheck__trace_m25p80_reset_done(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_RESET_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 222 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_reset_done " "[%p] Reset done." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 6864 "trace/trace-hw_block.h"
        } else {
#line 222 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_reset_done " "[%p] Reset done." "\n", s);
#line 6868 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_reset_done(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_reset_done(s);
    }
}

#define TRACE_M25P80_COMMAND_DECODED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMMAND_DECODED) || \
    false)

static inline void _nocheck__trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (trace_event_get_state(TRACE_M25P80_COMMAND_DECODED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 223 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd);
#line 6895 "trace/trace-hw_block.h"
        } else {
#line 223 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n", s, cmd);
#line 6899 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (true) {
        _nocheck__trace_m25p80_command_decoded(s, cmd);
    }
}

#define TRACE_M25P80_COMPLETE_COLLECTING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMPLETE_COLLECTING) || \
    false)

static inline void _nocheck__trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (trace_event_get_state(TRACE_M25P80_COMPLETE_COLLECTING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 224 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd, n, ear, cur_addr);
#line 6926 "trace/trace-hw_block.h"
        } else {
#line 224 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n", s, cmd, n, ear, cur_addr);
#line 6930 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (true) {
        _nocheck__trace_m25p80_complete_collecting(s, cmd, n, ear, cur_addr);
    }
}

#define TRACE_M25P80_POPULATED_JEDEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_POPULATED_JEDEC) || \
    false)

static inline void _nocheck__trace_m25p80_populated_jedec(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_POPULATED_JEDEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 225 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_populated_jedec " "[%p] populated jedec code" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 6957 "trace/trace-hw_block.h"
        } else {
#line 225 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_populated_jedec " "[%p] populated jedec code" "\n", s);
#line 6961 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_populated_jedec(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_populated_jedec(s);
    }
}

#define TRACE_M25P80_CHIP_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_CHIP_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_chip_erase(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_CHIP_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 226 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_chip_erase " "[%p] chip erase" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 6988 "trace/trace-hw_block.h"
        } else {
#line 226 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_chip_erase " "[%p] chip erase" "\n", s);
#line 6992 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_chip_erase(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_chip_erase(s);
    }
}

#define TRACE_M25P80_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_SELECT) || \
    false)

static inline void _nocheck__trace_m25p80_select(void * s, const char * what)
{
    if (trace_event_get_state(TRACE_M25P80_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 227 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_select " "[%p] %sselect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, what);
#line 7019 "trace/trace-hw_block.h"
        } else {
#line 227 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_select " "[%p] %sselect" "\n", s, what);
#line 7023 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_select(void * s, const char * what)
{
    if (true) {
        _nocheck__trace_m25p80_select(s, what);
    }
}

#define TRACE_M25P80_PAGE_PROGRAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PAGE_PROGRAM) || \
    false)

static inline void _nocheck__trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (trace_event_get_state(TRACE_M25P80_PAGE_PROGRAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 228 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, tx);
#line 7050 "trace/trace-hw_block.h"
        } else {
#line 228 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n", s, addr, tx);
#line 7054 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (true) {
        _nocheck__trace_m25p80_page_program(s, addr, tx);
    }
}

#define TRACE_M25P80_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_TRANSFER) || \
    false)

static inline void _nocheck__trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (trace_event_get_state(TRACE_M25P80_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 229 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, state, len, needed, pos, cur_addr, t);
#line 7081 "trace/trace-hw_block.h"
        } else {
#line 229 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n", s, state, len, needed, pos, cur_addr, t);
#line 7085 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (true) {
        _nocheck__trace_m25p80_transfer(s, state, len, needed, pos, cur_addr, t);
    }
}

#define TRACE_M25P80_READ_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_BYTE) || \
    false)

static inline void _nocheck__trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 230 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, v);
#line 7112 "trace/trace-hw_block.h"
        } else {
#line 230 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n", s, addr, v);
#line 7116 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_byte(s, addr, v);
    }
}

#define TRACE_M25P80_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_DATA) || \
    false)

static inline void _nocheck__trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 231 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, pos, v);
#line 7143 "trace/trace-hw_block.h"
        } else {
#line 231 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n", s, pos, v);
#line 7147 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_data(s, pos, v);
    }
}

#define TRACE_M25P80_BINDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING) || \
    false)

static inline void _nocheck__trace_m25p80_binding(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 232 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding " "[%p] Binding to IF_MTD drive" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 7174 "trace/trace-hw_block.h"
        } else {
#line 232 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_binding " "[%p] Binding to IF_MTD drive" "\n", s);
#line 7178 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding(s);
    }
}

#define TRACE_M25P80_BINDING_NO_BDRV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING_NO_BDRV) || \
    false)

static inline void _nocheck__trace_m25p80_binding_no_bdrv(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING_NO_BDRV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 233 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 7205 "trace/trace-hw_block.h"
        } else {
#line 233 "/home/lore/MasterThesis/qemu/hw/block/trace-events"
            qemu_log("m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n", s);
#line 7209 "trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding_no_bdrv(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding_no_bdrv(s);
    }
}
#endif /* TRACE_HW_BLOCK_GENERATED_TRACERS_H */
