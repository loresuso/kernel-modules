/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_CHAR_GENERATED_TRACERS_H
#define TRACE_HW_CHAR_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_PARALLEL_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_PARALLEL_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_READ_EVENT;
extern TraceEvent _TRACE_SERIAL_WRITE_EVENT;
extern TraceEvent _TRACE_SERIAL_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_READL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_LM32_JUART_GET_JTX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_SET_JTX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_GET_JRX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_SET_JRX_EVENT;
extern TraceEvent _TRACE_LM32_UART_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_LM32_UART_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_LM32_UART_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_RAISE_IRQ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_LOWER_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_PUT_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_GET_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_SERIAL_RECEIVE_BYTE_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_IN_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_OUT_EVENT;
extern TraceEvent _TRACE_ESCC_KBD_COMMAND_EVENT;
extern TraceEvent _TRACE_ESCC_SUNMOUSE_EVENT_EVENT;
extern TraceEvent _TRACE_PL011_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_PL011_READ_EVENT;
extern TraceEvent _TRACE_PL011_READ_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_WRITE_EVENT;
extern TraceEvent _TRACE_PL011_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_FULL_EVENT;
extern TraceEvent _TRACE_PL011_BAUDRATE_CHANGE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_READ_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_WRITE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RESET_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_RECEIVE_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_PENDING_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_TX_EVENT;
extern TraceEvent _TRACE_CMSDK_APB_UART_SET_PARAMS_EVENT;
extern TraceEvent _TRACE_NRF51_UART_READ_EVENT;
extern TraceEvent _TRACE_NRF51_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMABUSY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_DMAREADY_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_RAISED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_IRQ_LOWERED_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_UPDATE_PARAMS_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_FIFO_RESET_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_TX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_INTCLR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RO_WRITE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_WO_READ_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RXSIZE_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_CHANNEL_ERROR_EVENT;
extern TraceEvent _TRACE_EXYNOS_UART_RX_TIMEOUT_EVENT;
extern TraceEvent _TRACE_CADENCE_UART_BAUDRATE_EVENT;
extern uint16_t _TRACE_PARALLEL_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_PARALLEL_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_READ_DSTATE;
extern uint16_t _TRACE_SERIAL_WRITE_DSTATE;
extern uint16_t _TRACE_SERIAL_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_READL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_LM32_JUART_GET_JTX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_SET_JTX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_GET_JRX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_SET_JRX_DSTATE;
extern uint16_t _TRACE_LM32_UART_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_LM32_UART_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_LM32_UART_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_RAISE_IRQ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_LOWER_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_PUT_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_GET_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_SERIAL_RECEIVE_BYTE_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_IN_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_OUT_DSTATE;
extern uint16_t _TRACE_ESCC_KBD_COMMAND_DSTATE;
extern uint16_t _TRACE_ESCC_SUNMOUSE_EVENT_DSTATE;
extern uint16_t _TRACE_PL011_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_PL011_READ_DSTATE;
extern uint16_t _TRACE_PL011_READ_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_WRITE_DSTATE;
extern uint16_t _TRACE_PL011_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_FULL_DSTATE;
extern uint16_t _TRACE_PL011_BAUDRATE_CHANGE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_READ_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_WRITE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RESET_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_RECEIVE_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_PENDING_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_TX_DSTATE;
extern uint16_t _TRACE_CMSDK_APB_UART_SET_PARAMS_DSTATE;
extern uint16_t _TRACE_NRF51_UART_READ_DSTATE;
extern uint16_t _TRACE_NRF51_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMABUSY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_DMAREADY_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_RAISED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_IRQ_LOWERED_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_UPDATE_PARAMS_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_FIFO_RESET_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_TX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_INTCLR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RO_WRITE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_WO_READ_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RXSIZE_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_CHANNEL_ERROR_DSTATE;
extern uint16_t _TRACE_EXYNOS_UART_RX_TIMEOUT_DSTATE;
extern uint16_t _TRACE_CADENCE_UART_BAUDRATE_DSTATE;
#define TRACE_PARALLEL_IOPORT_READ_ENABLED 1
#define TRACE_PARALLEL_IOPORT_WRITE_ENABLED 1
#define TRACE_SERIAL_READ_ENABLED 1
#define TRACE_SERIAL_WRITE_ENABLED 1
#define TRACE_SERIAL_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_READ_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_ENABLED 1
#define TRACE_GRLIB_APBUART_READL_UNKNOWN_ENABLED 1
#define TRACE_LM32_JUART_GET_JTX_ENABLED 1
#define TRACE_LM32_JUART_SET_JTX_ENABLED 1
#define TRACE_LM32_JUART_GET_JRX_ENABLED 1
#define TRACE_LM32_JUART_SET_JRX_ENABLED 1
#define TRACE_LM32_UART_MEMORY_WRITE_ENABLED 1
#define TRACE_LM32_UART_MEMORY_READ_ENABLED 1
#define TRACE_LM32_UART_IRQ_STATE_ENABLED 1
#define TRACE_MILKYMIST_UART_MEMORY_READ_ENABLED 1
#define TRACE_MILKYMIST_UART_MEMORY_WRITE_ENABLED 1
#define TRACE_MILKYMIST_UART_RAISE_IRQ_ENABLED 1
#define TRACE_MILKYMIST_UART_LOWER_IRQ_ENABLED 1
#define TRACE_ESCC_PUT_QUEUE_ENABLED 1
#define TRACE_ESCC_GET_QUEUE_ENABLED 1
#define TRACE_ESCC_UPDATE_IRQ_ENABLED 1
#define TRACE_ESCC_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_DATA_ENABLED 1
#define TRACE_ESCC_MEM_READB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_READB_DATA_ENABLED 1
#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_IN_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_OUT_ENABLED 1
#define TRACE_ESCC_KBD_COMMAND_ENABLED 1
#define TRACE_ESCC_SUNMOUSE_EVENT_ENABLED 1
#define TRACE_PL011_IRQ_STATE_ENABLED 1
#define TRACE_PL011_READ_ENABLED 1
#define TRACE_PL011_READ_FIFO_ENABLED 1
#define TRACE_PL011_WRITE_ENABLED 1
#define TRACE_PL011_CAN_RECEIVE_ENABLED 1
#define TRACE_PL011_PUT_FIFO_ENABLED 1
#define TRACE_PL011_PUT_FIFO_FULL_ENABLED 1
#define TRACE_PL011_BAUDRATE_CHANGE_ENABLED 1
#define TRACE_CMSDK_APB_UART_READ_ENABLED 1
#define TRACE_CMSDK_APB_UART_WRITE_ENABLED 1
#define TRACE_CMSDK_APB_UART_RESET_ENABLED 1
#define TRACE_CMSDK_APB_UART_RECEIVE_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_PENDING_ENABLED 1
#define TRACE_CMSDK_APB_UART_TX_ENABLED 1
#define TRACE_CMSDK_APB_UART_SET_PARAMS_ENABLED 1
#define TRACE_NRF51_UART_READ_ENABLED 1
#define TRACE_NRF51_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_DMABUSY_ENABLED 1
#define TRACE_EXYNOS_UART_DMAREADY_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_RAISED_ENABLED 1
#define TRACE_EXYNOS_UART_IRQ_LOWERED_ENABLED 1
#define TRACE_EXYNOS_UART_UPDATE_PARAMS_ENABLED 1
#define TRACE_EXYNOS_UART_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_FIFO_RESET_ENABLED 1
#define TRACE_EXYNOS_UART_TX_ENABLED 1
#define TRACE_EXYNOS_UART_INTCLR_ENABLED 1
#define TRACE_EXYNOS_UART_RO_WRITE_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ENABLED 1
#define TRACE_EXYNOS_UART_RX_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_WO_READ_ENABLED 1
#define TRACE_EXYNOS_UART_RXSIZE_ENABLED 1
#define TRACE_EXYNOS_UART_CHANNEL_ERROR_ENABLED 1
#define TRACE_EXYNOS_UART_RX_TIMEOUT_ENABLED 1
#define TRACE_CADENCE_UART_BAUDRATE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_PARALLEL_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 253 "trace/trace-hw_char.h"
        } else {
#line 4 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("parallel_ioport_read " "read [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 257 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_read(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_read(desc, addr, value);
    }
}

#define TRACE_PARALLEL_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PARALLEL_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_PARALLEL_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, addr, value);
#line 284 "trace/trace-hw_char.h"
        } else {
#line 5 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("parallel_ioport_write " "write [%s] addr 0x%02x val 0x%02x" "\n", desc, addr, value);
#line 288 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_parallel_ioport_write(const char * desc, uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_parallel_ioport_write(desc, addr, value);
    }
}

#define TRACE_SERIAL_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_READ) || \
    false)

static inline void _nocheck__trace_serial_read(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_read " "read addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 315 "trace/trace-hw_char.h"
        } else {
#line 8 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("serial_read " "read addr 0x%02x val 0x%02x" "\n", addr, value);
#line 319 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_read(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_read(addr, value);
    }
}

#define TRACE_SERIAL_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_WRITE) || \
    false)

static inline void _nocheck__trace_serial_write(uint16_t addr, uint8_t value)
{
    if (trace_event_get_state(TRACE_SERIAL_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_write " "write addr 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 346 "trace/trace-hw_char.h"
        } else {
#line 9 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("serial_write " "write addr 0x%02x val 0x%02x" "\n", addr, value);
#line 350 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_write(uint16_t addr, uint8_t value)
{
    if (true) {
        _nocheck__trace_serial_write(addr, value);
    }
}

#define TRACE_SERIAL_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SERIAL_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_SERIAL_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, parity, data_bits, stop_bits);
#line 377 "trace/trace-hw_char.h"
        } else {
#line 10 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("serial_update_parameters " "baudrate=%"PRIu64" parity='%c' data=%d stop=%d" "\n", baudrate, parity, data_bits, stop_bits);
#line 381 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_serial_update_parameters(uint64_t baudrate, char parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_serial_update_parameters(baudrate, parity, data_bits, stop_bits);
    }
}

#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_send_control_event " "port %u, event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event, value);
#line 408 "trace/trace-hw_char.h"
        } else {
#line 13 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_send_control_event " "port %u, event %u, value %u" "\n", port, event, value);
#line 412 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_send_control_event(port, event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_THROTTLE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_throttle_port " "port %u, throttle %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, throttle);
#line 439 "trace/trace-hw_char.h"
        } else {
#line 14 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_throttle_port " "port %u, throttle %d" "\n", port, throttle);
#line 443 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (true) {
        _nocheck__trace_virtio_serial_throttle_port(port, throttle);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message " "event %u, value %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event, value);
#line 470 "trace/trace-hw_char.h"
        } else {
#line 15 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message " "event %u, value %u" "\n", event, value);
#line 474 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message(event, value);
    }
}

#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) || \
    false)

static inline void _nocheck__trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_serial_handle_control_message_port " "port %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port);
#line 501 "trace/trace-hw_char.h"
        } else {
#line 16 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("virtio_serial_handle_control_message_port " "port %u" "\n", port);
#line 505 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (true) {
        _nocheck__trace_virtio_serial_handle_control_message_port(port);
    }
}

#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) || \
    false)

static inline void _nocheck__trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_FLUSH_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, len, ret);
#line 532 "trace/trace-hw_char.h"
        } else {
#line 19 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n", port, len, ret);
#line 536 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (true) {
        _nocheck__trace_virtio_console_flush_buf(port, len, ret);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_READ) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_read " "port %u, size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, size);
#line 563 "trace/trace-hw_char.h"
        } else {
#line 20 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("virtio_console_chr_read " "port %u, size %d" "\n", port, size);
#line 567 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_read(port, size);
    }
}

#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_CONSOLE_CHR_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_console_chr_event " "port %u, event %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , port, event);
#line 594 "trace/trace-hw_char.h"
        } else {
#line 21 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("virtio_console_chr_event " "port %u, event %d" "\n", port, event);
#line 598 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (true) {
        _nocheck__trace_virtio_console_chr_event(port, event);
    }
}

#define TRACE_GRLIB_APBUART_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_EVENT) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_event(int event)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_event " "event:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , event);
#line 625 "trace/trace-hw_char.h"
        } else {
#line 24 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("grlib_apbuart_event " "event:%d" "\n", event);
#line 629 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_event(int event)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_event(event);
    }
}

#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 656 "trace/trace-hw_char.h"
        } else {
#line 25 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n", addr, value);
#line 660 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_writel_unknown(addr, value);
    }
}

#define TRACE_GRLIB_APBUART_READL_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GRLIB_APBUART_READL_UNKNOWN) || \
    false)

static inline void _nocheck__trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (trace_event_get_state(TRACE_GRLIB_APBUART_READL_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 687 "trace/trace-hw_char.h"
        } else {
#line 26 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n", addr);
#line 691 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (true) {
        _nocheck__trace_grlib_apbuart_readl_unknown(addr);
    }
}

#define TRACE_LM32_JUART_GET_JTX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_GET_JTX) || \
    false)

static inline void _nocheck__trace_lm32_juart_get_jtx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_GET_JTX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:lm32_juart_get_jtx " "jtx 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 718 "trace/trace-hw_char.h"
        } else {
#line 29 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("lm32_juart_get_jtx " "jtx 0x%08x" "\n", value);
#line 722 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_lm32_juart_get_jtx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_get_jtx(value);
    }
}

#define TRACE_LM32_JUART_SET_JTX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_SET_JTX) || \
    false)

static inline void _nocheck__trace_lm32_juart_set_jtx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_SET_JTX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:lm32_juart_set_jtx " "jtx 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 749 "trace/trace-hw_char.h"
        } else {
#line 30 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("lm32_juart_set_jtx " "jtx 0x%08x" "\n", value);
#line 753 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_lm32_juart_set_jtx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_set_jtx(value);
    }
}

#define TRACE_LM32_JUART_GET_JRX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_GET_JRX) || \
    false)

static inline void _nocheck__trace_lm32_juart_get_jrx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_GET_JRX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:lm32_juart_get_jrx " "jrx 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 780 "trace/trace-hw_char.h"
        } else {
#line 31 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("lm32_juart_get_jrx " "jrx 0x%08x" "\n", value);
#line 784 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_lm32_juart_get_jrx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_get_jrx(value);
    }
}

#define TRACE_LM32_JUART_SET_JRX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_JUART_SET_JRX) || \
    false)

static inline void _nocheck__trace_lm32_juart_set_jrx(uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_JUART_SET_JRX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:lm32_juart_set_jrx " "jrx 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , value);
#line 811 "trace/trace-hw_char.h"
        } else {
#line 32 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("lm32_juart_set_jrx " "jrx 0x%08x" "\n", value);
#line 815 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_lm32_juart_set_jrx(uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_juart_set_jrx(value);
    }
}

#define TRACE_LM32_UART_MEMORY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_UART_MEMORY_WRITE) || \
    false)

static inline void _nocheck__trace_lm32_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_UART_MEMORY_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:lm32_uart_memory_write " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 842 "trace/trace-hw_char.h"
        } else {
#line 35 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("lm32_uart_memory_write " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 846 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_lm32_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_uart_memory_write(addr, value);
    }
}

#define TRACE_LM32_UART_MEMORY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_UART_MEMORY_READ) || \
    false)

static inline void _nocheck__trace_lm32_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_LM32_UART_MEMORY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:lm32_uart_memory_read " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 873 "trace/trace-hw_char.h"
        } else {
#line 36 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("lm32_uart_memory_read " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 877 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_lm32_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_lm32_uart_memory_read(addr, value);
    }
}

#define TRACE_LM32_UART_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LM32_UART_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_lm32_uart_irq_state(int level)
{
    if (trace_event_get_state(TRACE_LM32_UART_IRQ_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:lm32_uart_irq_state " "irq state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 904 "trace/trace-hw_char.h"
        } else {
#line 37 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("lm32_uart_irq_state " "irq state %d" "\n", level);
#line 908 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_lm32_uart_irq_state(int level)
{
    if (true) {
        _nocheck__trace_lm32_uart_irq_state(level);
    }
}

#define TRACE_MILKYMIST_UART_MEMORY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_MEMORY_READ) || \
    false)

static inline void _nocheck__trace_milkymist_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:milkymist_uart_memory_read " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 935 "trace/trace-hw_char.h"
        } else {
#line 40 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("milkymist_uart_memory_read " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 939 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_milkymist_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_milkymist_uart_memory_read(addr, value);
    }
}

#define TRACE_MILKYMIST_UART_MEMORY_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_MEMORY_WRITE) || \
    false)

static inline void _nocheck__trace_milkymist_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:milkymist_uart_memory_write " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 966 "trace/trace-hw_char.h"
        } else {
#line 41 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("milkymist_uart_memory_write " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 970 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_milkymist_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_milkymist_uart_memory_write(addr, value);
    }
}

#define TRACE_MILKYMIST_UART_RAISE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_RAISE_IRQ) || \
    false)

static inline void _nocheck__trace_milkymist_uart_raise_irq(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_RAISE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:milkymist_uart_raise_irq " "Raise IRQ" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 997 "trace/trace-hw_char.h"
        } else {
#line 42 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("milkymist_uart_raise_irq " "Raise IRQ" "\n");
#line 1001 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_milkymist_uart_raise_irq(void)
{
    if (true) {
        _nocheck__trace_milkymist_uart_raise_irq();
    }
}

#define TRACE_MILKYMIST_UART_LOWER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MILKYMIST_UART_LOWER_IRQ) || \
    false)

static inline void _nocheck__trace_milkymist_uart_lower_irq(void)
{
    if (trace_event_get_state(TRACE_MILKYMIST_UART_LOWER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:milkymist_uart_lower_irq " "Lower IRQ" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1028 "trace/trace-hw_char.h"
        } else {
#line 43 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("milkymist_uart_lower_irq " "Lower IRQ" "\n");
#line 1032 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_milkymist_uart_lower_irq(void)
{
    if (true) {
        _nocheck__trace_milkymist_uart_lower_irq();
    }
}

#define TRACE_ESCC_PUT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_PUT_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_put_queue(char channel, int b)
{
    if (trace_event_get_state(TRACE_ESCC_PUT_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_put_queue " "channel %c put: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, b);
#line 1059 "trace/trace-hw_char.h"
        } else {
#line 46 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_put_queue " "channel %c put: 0x%02x" "\n", channel, b);
#line 1063 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_put_queue(char channel, int b)
{
    if (true) {
        _nocheck__trace_escc_put_queue(channel, b);
    }
}

#define TRACE_ESCC_GET_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_GET_QUEUE) || \
    false)

static inline void _nocheck__trace_escc_get_queue(char channel, int val)
{
    if (trace_event_get_state(TRACE_ESCC_GET_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_get_queue " "channel %c get 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1090 "trace/trace-hw_char.h"
        } else {
#line 47 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_get_queue " "channel %c get 0x%02x" "\n", channel, val);
#line 1094 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_get_queue(char channel, int val)
{
    if (true) {
        _nocheck__trace_escc_get_queue(channel, val);
    }
}

#define TRACE_ESCC_UPDATE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_IRQ) || \
    false)

static inline void _nocheck__trace_escc_update_irq(int irq)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_irq " "IRQ = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq);
#line 1121 "trace/trace-hw_char.h"
        } else {
#line 48 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_update_irq " "IRQ = %d" "\n", irq);
#line 1125 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_irq(int irq)
{
    if (true) {
        _nocheck__trace_escc_update_irq(irq);
    }
}

#define TRACE_ESCC_UPDATE_PARAMETERS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_UPDATE_PARAMETERS) || \
    false)

static inline void _nocheck__trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (trace_event_get_state(TRACE_ESCC_UPDATE_PARAMETERS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data_bits, stop_bits);
#line 1152 "trace/trace-hw_char.h"
        } else {
#line 49 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n", channel, speed, parity, data_bits, stop_bits);
#line 1156 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (true) {
        _nocheck__trace_escc_update_parameters(channel, speed, parity, data_bits, stop_bits);
    }
}

#define TRACE_ESCC_MEM_WRITEB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1183 "trace/trace-hw_char.h"
        } else {
#line 50 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1187 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_WRITEB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_WRITEB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_writeb_data " "Write channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, val);
#line 1214 "trace/trace-hw_char.h"
        } else {
#line 51 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_mem_writeb_data " "Write channel %c, ch %d" "\n", channel, val);
#line 1218 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_writeb_data(channel, val);
    }
}

#define TRACE_ESCC_MEM_READB_CTRL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_CTRL) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_CTRL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg, val);
#line 1245 "trace/trace-hw_char.h"
        } else {
#line 52 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_mem_readb_ctrl " "Read channel %c, reg[%d] = 0x%2.2x" "\n", channel, reg, val);
#line 1249 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_ctrl(channel, reg, val);
    }
}

#define TRACE_ESCC_MEM_READB_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_MEM_READB_DATA) || \
    false)

static inline void _nocheck__trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (trace_event_get_state(TRACE_ESCC_MEM_READB_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_mem_readb_data " "Read channel %c, ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ret);
#line 1276 "trace/trace-hw_char.h"
        } else {
#line 53 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_mem_readb_data " "Read channel %c, ch %d" "\n", channel, ret);
#line 1280 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (true) {
        _nocheck__trace_escc_mem_readb_data(channel, ret);
    }
}

#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SERIAL_RECEIVE_BYTE) || \
    false)

static inline void _nocheck__trace_escc_serial_receive_byte(char channel, int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SERIAL_RECEIVE_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_serial_receive_byte " "channel %c put ch %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 1307 "trace/trace-hw_char.h"
        } else {
#line 54 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_serial_receive_byte " "channel %c put ch %d" "\n", channel, ch);
#line 1311 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_serial_receive_byte(char channel, int ch)
{
    if (true) {
        _nocheck__trace_escc_serial_receive_byte(channel, ch);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_IN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_IN) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_IN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch, name, down);
#line 1338 "trace/trace-hw_char.h"
        } else {
#line 55 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n", ch, name, down);
#line 1342 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_in(ch, name, down);
    }
}

#define TRACE_ESCC_SUNKBD_EVENT_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNKBD_EVENT_OUT) || \
    false)

static inline void _nocheck__trace_escc_sunkbd_event_out(int ch)
{
    if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 1369 "trace/trace-hw_char.h"
        } else {
#line 56 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n", ch);
#line 1373 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunkbd_event_out(int ch)
{
    if (true) {
        _nocheck__trace_escc_sunkbd_event_out(ch);
    }
}

#define TRACE_ESCC_KBD_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_KBD_COMMAND) || \
    false)

static inline void _nocheck__trace_escc_kbd_command(int val)
{
    if (trace_event_get_state(TRACE_ESCC_KBD_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_kbd_command " "Command %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 1400 "trace/trace-hw_char.h"
        } else {
#line 57 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_kbd_command " "Command %d" "\n", val);
#line 1404 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_kbd_command(int val)
{
    if (true) {
        _nocheck__trace_escc_kbd_command(val);
    }
}

#define TRACE_ESCC_SUNMOUSE_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESCC_SUNMOUSE_EVENT) || \
    false)

static inline void _nocheck__trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (trace_event_get_state(TRACE_ESCC_SUNMOUSE_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dx, dy, buttons_state);
#line 1431 "trace/trace-hw_char.h"
        } else {
#line 58 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("escc_sunmouse_event " "dx=%d dy=%d buttons=0x%01x" "\n", dx, dy, buttons_state);
#line 1435 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (true) {
        _nocheck__trace_escc_sunmouse_event(dx, dy, buttons_state);
    }
}

#define TRACE_PL011_IRQ_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_IRQ_STATE) || \
    false)

static inline void _nocheck__trace_pl011_irq_state(int level)
{
    if (trace_event_get_state(TRACE_PL011_IRQ_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_irq_state " "irq state %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 1462 "trace/trace-hw_char.h"
        } else {
#line 61 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_irq_state " "irq state %d" "\n", level);
#line 1466 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_irq_state(int level)
{
    if (true) {
        _nocheck__trace_pl011_irq_state(level);
    }
}

#define TRACE_PL011_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ) || \
    false)

static inline void _nocheck__trace_pl011_read(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_PL011_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 1493 "trace/trace-hw_char.h"
        } else {
#line 62 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_read " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 1497 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_pl011_read(addr, value);
    }
}

#define TRACE_PL011_READ_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_READ_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_read_fifo(int read_count)
{
    if (trace_event_get_state(TRACE_PL011_READ_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_read_fifo " "FIFO read, read_count now %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , read_count);
#line 1524 "trace/trace-hw_char.h"
        } else {
#line 63 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_read_fifo " "FIFO read, read_count now %d" "\n", read_count);
#line 1528 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_read_fifo(int read_count)
{
    if (true) {
        _nocheck__trace_pl011_read_fifo(read_count);
    }
}

#define TRACE_PL011_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_WRITE) || \
    false)

static inline void _nocheck__trace_pl011_write(uint32_t addr, uint32_t value)
{
    if (trace_event_get_state(TRACE_PL011_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_write " "addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value);
#line 1555 "trace/trace-hw_char.h"
        } else {
#line 64 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_write " "addr 0x%08x value 0x%08x" "\n", addr, value);
#line 1559 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_write(uint32_t addr, uint32_t value)
{
    if (true) {
        _nocheck__trace_pl011_write(addr, value);
    }
}

#define TRACE_PL011_CAN_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_CAN_RECEIVE) || \
    false)

static inline void _nocheck__trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (trace_event_get_state(TRACE_PL011_CAN_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_can_receive " "LCR 0x%08x read_count %d returning %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lcr, read_count, r);
#line 1586 "trace/trace-hw_char.h"
        } else {
#line 65 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_can_receive " "LCR 0x%08x read_count %d returning %d" "\n", lcr, read_count, r);
#line 1590 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (true) {
        _nocheck__trace_pl011_can_receive(lcr, read_count, r);
    }
}

#define TRACE_PL011_PUT_FIFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_put_fifo " "new char 0x%x read_count now %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c, read_count);
#line 1617 "trace/trace-hw_char.h"
        } else {
#line 66 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_put_fifo " "new char 0x%x read_count now %d" "\n", c, read_count);
#line 1621 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo(c, read_count);
    }
}

#define TRACE_PL011_PUT_FIFO_FULL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_PUT_FIFO_FULL) || \
    false)

static inline void _nocheck__trace_pl011_put_fifo_full(void)
{
    if (trace_event_get_state(TRACE_PL011_PUT_FIFO_FULL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_put_fifo_full " "FIFO now full, RXFF set" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1648 "trace/trace-hw_char.h"
        } else {
#line 67 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_put_fifo_full " "FIFO now full, RXFF set" "\n");
#line 1652 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_put_fifo_full(void)
{
    if (true) {
        _nocheck__trace_pl011_put_fifo_full();
    }
}

#define TRACE_PL011_BAUDRATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PL011_BAUDRATE_CHANGE) || \
    false)

static inline void _nocheck__trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (trace_event_get_state(TRACE_PL011_BAUDRATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate, clock, ibrd, fbrd);
#line 1679 "trace/trace-hw_char.h"
        } else {
#line 68 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("pl011_baudrate_change " "new baudrate %u (clk: %" PRIu64 "hz, ibrd: %" PRIu32 ", fbrd: %" PRIu32 ")" "\n", baudrate, clock, ibrd, fbrd);
#line 1683 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_pl011_baudrate_change(unsigned int baudrate, uint64_t clock, uint32_t ibrd, uint32_t fbrd)
{
    if (true) {
        _nocheck__trace_pl011_baudrate_change(baudrate, clock, ibrd, fbrd);
    }
}

#define TRACE_CMSDK_APB_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_READ) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1710 "trace/trace-hw_char.h"
        } else {
#line 71 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_read " "CMSDK APB UART read: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1714 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_read(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_read(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_WRITE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, data, size);
#line 1741 "trace/trace-hw_char.h"
        } else {
#line 72 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_write " "CMSDK APB UART write: offset 0x%" PRIx64 " data 0x%" PRIx64 " size %u" "\n", offset, data, size);
#line 1745 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_write(uint64_t offset, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_write(offset, data, size);
    }
}

#define TRACE_CMSDK_APB_UART_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RESET) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_reset(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1772 "trace/trace-hw_char.h"
        } else {
#line 73 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_reset " "CMSDK APB UART: reset" "\n");
#line 1776 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_reset(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_reset();
    }
}

#define TRACE_CMSDK_APB_UART_RECEIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_RECEIVE) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_RECEIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 1803 "trace/trace-hw_char.h"
        } else {
#line 74 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_receive " "CMSDK APB UART: got character 0x%x from backend" "\n", c);
#line 1807 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_receive(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_receive(c);
    }
}

#define TRACE_CMSDK_APB_UART_TX_PENDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX_PENDING) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx_pending(void)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX_PENDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1834 "trace/trace-hw_char.h"
        } else {
#line 75 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx_pending " "CMSDK APB UART: character send to backend pending" "\n");
#line 1838 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx_pending(void)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx_pending();
    }
}

#define TRACE_CMSDK_APB_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_TX) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c);
#line 1865 "trace/trace-hw_char.h"
        } else {
#line 76 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_tx " "CMSDK APB UART: character 0x%x sent to backend" "\n", c);
#line 1869 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_tx(uint8_t c)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_tx(c);
    }
}

#define TRACE_CMSDK_APB_UART_SET_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CMSDK_APB_UART_SET_PARAMS) || \
    false)

static inline void _nocheck__trace_cmsdk_apb_uart_set_params(int speed)
{
    if (trace_event_get_state(TRACE_CMSDK_APB_UART_SET_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , speed);
#line 1896 "trace/trace-hw_char.h"
        } else {
#line 77 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cmsdk_apb_uart_set_params " "CMSDK APB UART: params set to %d 8N1" "\n", speed);
#line 1900 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cmsdk_apb_uart_set_params(int speed)
{
    if (true) {
        _nocheck__trace_cmsdk_apb_uart_set_params(speed);
    }
}

#define TRACE_NRF51_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_READ) || \
    false)

static inline void _nocheck__trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, r, size);
#line 1927 "trace/trace-hw_char.h"
        } else {
#line 80 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("nrf51_uart_read " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, r, size);
#line 1931 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_read(uint64_t addr, uint64_t r, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_read(addr, r, size);
    }
}

#define TRACE_NRF51_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_NRF51_UART_WRITE) || \
    false)

static inline void _nocheck__trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (trace_event_get_state(TRACE_NRF51_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, value, size);
#line 1958 "trace/trace-hw_char.h"
        } else {
#line 81 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("nrf51_uart_write " "addr 0x%" PRIx64 " value 0x%" PRIx64 " size %u" "\n", addr, value, size);
#line 1962 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_nrf51_uart_write(uint64_t addr, uint64_t value, unsigned int size)
{
    if (true) {
        _nocheck__trace_nrf51_uart_write(addr, value, size);
    }
}

#define TRACE_EXYNOS_UART_DMABUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMABUSY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMABUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 1989 "trace/trace-hw_char.h"
        } else {
#line 84 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_dmabusy " "UART%d: DMA busy (Rx buffer empty)" "\n", channel);
#line 1993 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmabusy(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmabusy(channel);
    }
}

#define TRACE_EXYNOS_UART_DMAREADY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_DMAREADY) || \
    false)

static inline void _nocheck__trace_exynos_uart_dmaready(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_DMAREADY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_dmaready " "UART%d: DMA ready" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2020 "trace/trace-hw_char.h"
        } else {
#line 85 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_dmaready " "UART%d: DMA ready" "\n", channel);
#line 2024 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_dmaready(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_dmaready(channel);
    }
}

#define TRACE_EXYNOS_UART_IRQ_RAISED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_RAISED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_RAISED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2051 "trace/trace-hw_char.h"
        } else {
#line 86 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_irq_raised " "UART%d: IRQ raised: 0x%08"PRIx32 "\n", channel, reg);
#line 2055 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_raised(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_raised(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_IRQ_LOWERED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_IRQ_LOWERED) || \
    false)

static inline void _nocheck__trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_IRQ_LOWERED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2082 "trace/trace-hw_char.h"
        } else {
#line 87 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_irq_lowered " "UART%d: IRQ lowered" "\n", channel);
#line 2086 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_irq_lowered(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_irq_lowered(channel);
    }
}

#define TRACE_EXYNOS_UART_UPDATE_PARAMS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_UPDATE_PARAMS) || \
    false)

static inline void _nocheck__trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_UPDATE_PARAMS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, speed, parity, data, stop, wordtime);
#line 2113 "trace/trace-hw_char.h"
        } else {
#line 88 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_update_params " "UART%d: speed: %d, parity: %c, data bits: %d, stop bits: %d wordtime: %"PRId64"ns" "\n", channel, speed, parity, data, stop, wordtime);
#line 2117 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_update_params(uint32_t channel, int speed, uint8_t parity, int data, int stop, uint64_t wordtime)
{
    if (true) {
        _nocheck__trace_exynos_uart_update_params(channel, speed, parity, data, stop, wordtime);
    }
}

#define TRACE_EXYNOS_UART_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2144 "trace/trace-hw_char.h"
        } else {
#line 89 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_write " "UART%d: <0x%04x> %s <- 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2148 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_write(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_write(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, offset, name, val);
#line 2175 "trace/trace-hw_char.h"
        } else {
#line 90 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_read " "UART%d: <0x%04x> %s -> 0x%" PRIx64 "\n", channel, offset, name, val);
#line 2179 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_read(uint32_t channel, uint32_t offset, const char * name, uint64_t val)
{
    if (true) {
        _nocheck__trace_exynos_uart_read(channel, offset, name, val);
    }
}

#define TRACE_EXYNOS_UART_RX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2206 "trace/trace-hw_char.h"
        } else {
#line 91 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx_fifo_reset " "UART%d: Rx FIFO Reset" "\n", channel);
#line 2210 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_FIFO_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX_FIFO_RESET) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX_FIFO_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2237 "trace/trace-hw_char.h"
        } else {
#line 92 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_tx_fifo_reset " "UART%d: Tx FIFO Reset" "\n", channel);
#line 2241 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx_fifo_reset(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx_fifo_reset(channel);
    }
}

#define TRACE_EXYNOS_UART_TX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_TX) || \
    false)

static inline void _nocheck__trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_TX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2268 "trace/trace-hw_char.h"
        } else {
#line 93 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_tx " "UART%d: Tx 0x%02"PRIx32 "\n", channel, ch);
#line 2272 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_tx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_tx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_INTCLR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_INTCLR) || \
    false)

static inline void _nocheck__trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_INTCLR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, reg);
#line 2299 "trace/trace-hw_char.h"
        } else {
#line 94 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_intclr " "UART%d: interrupts cleared: 0x%08"PRIx32 "\n", channel, reg);
#line 2303 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_intclr(uint32_t channel, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_intclr(channel, reg);
    }
}

#define TRACE_EXYNOS_UART_RO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RO_WRITE) || \
    false)

static inline void _nocheck__trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2330 "trace/trace-hw_char.h"
        } else {
#line 95 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_ro_write " "UART%d: Trying to write into RO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2334 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_ro_write(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_ro_write(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, ch);
#line 2361 "trace/trace-hw_char.h"
        } else {
#line 96 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx " "UART%d: Rx 0x%02"PRIx32 "\n", channel, ch);
#line 2365 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx(uint32_t channel, uint8_t ch)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx(channel, ch);
    }
}

#define TRACE_EXYNOS_UART_RX_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_error " "UART%d: Rx error" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2392 "trace/trace-hw_char.h"
        } else {
#line 97 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx_error " "UART%d: Rx error" "\n", channel);
#line 2396 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_error(channel);
    }
}

#define TRACE_EXYNOS_UART_WO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_WO_READ) || \
    false)

static inline void _nocheck__trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_WO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, name, reg);
#line 2423 "trace/trace-hw_char.h"
        } else {
#line 98 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_wo_read " "UART%d: Trying to read from WO register: %s [0x%04"PRIx32"]" "\n", channel, name, reg);
#line 2427 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_wo_read(uint32_t channel, const char * name, uint32_t reg)
{
    if (true) {
        _nocheck__trace_exynos_uart_wo_read(channel, name, reg);
    }
}

#define TRACE_EXYNOS_UART_RXSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RXSIZE) || \
    false)

static inline void _nocheck__trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RXSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, size);
#line 2454 "trace/trace-hw_char.h"
        } else {
#line 99 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rxsize " "UART%d: Rx FIFO size: %d" "\n", channel, size);
#line 2458 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rxsize(uint32_t channel, uint32_t size)
{
    if (true) {
        _nocheck__trace_exynos_uart_rxsize(channel, size);
    }
}

#define TRACE_EXYNOS_UART_CHANNEL_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_CHANNEL_ERROR) || \
    false)

static inline void _nocheck__trace_exynos_uart_channel_error(uint32_t channel)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_CHANNEL_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_channel_error " "Wrong UART channel number: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel);
#line 2485 "trace/trace-hw_char.h"
        } else {
#line 100 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_channel_error " "Wrong UART channel number: %d" "\n", channel);
#line 2489 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_channel_error(uint32_t channel)
{
    if (true) {
        _nocheck__trace_exynos_uart_channel_error(channel);
    }
}

#define TRACE_EXYNOS_UART_RX_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_EXYNOS_UART_RX_TIMEOUT) || \
    false)

static inline void _nocheck__trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (trace_event_get_state(TRACE_EXYNOS_UART_RX_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , channel, stat, intsp);
#line 2516 "trace/trace-hw_char.h"
        } else {
#line 101 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("exynos_uart_rx_timeout " "UART%d: Rx timeout stat=0x%x intsp=0x%x" "\n", channel, stat, intsp);
#line 2520 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_exynos_uart_rx_timeout(uint32_t channel, uint32_t stat, uint32_t intsp)
{
    if (true) {
        _nocheck__trace_exynos_uart_rx_timeout(channel, stat, intsp);
    }
}

#define TRACE_CADENCE_UART_BAUDRATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CADENCE_UART_BAUDRATE) || \
    false)

static inline void _nocheck__trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (trace_event_get_state(TRACE_CADENCE_UART_BAUDRATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("%d@%zu.%06zu:cadence_uart_baudrate " "baudrate %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , baudrate);
#line 2547 "trace/trace-hw_char.h"
        } else {
#line 104 "/home/lore/MasterThesis/qemu/hw/char/trace-events"
            qemu_log("cadence_uart_baudrate " "baudrate %u" "\n", baudrate);
#line 2551 "trace/trace-hw_char.h"
        }
    }
}

static inline void trace_cadence_uart_baudrate(unsigned baudrate)
{
    if (true) {
        _nocheck__trace_cadence_uart_baudrate(baudrate);
    }
}
#endif /* TRACE_HW_CHAR_GENERATED_TRACERS_H */
