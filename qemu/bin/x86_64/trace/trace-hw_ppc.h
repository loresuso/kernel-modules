/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_PPC_GENERATED_TRACERS_H
#define TRACE_HW_PPC_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_SPAPR_PCI_MSI_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_SETUP_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_WRITE_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_LSI_SET_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_RETRY_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_CONTINUE_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_PVR_EVENT;
extern TraceEvent _TRACE_SPAPR_H_RESIZE_HPT_PREPARE_EVENT;
extern TraceEvent _TRACE_SPAPR_H_RESIZE_HPT_COMMIT_EVENT;
extern TraceEvent _TRACE_SPAPR_UPDATE_DT_EVENT;
extern TraceEvent _TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_EVENT;
extern TraceEvent _TRACE_SPAPR_H_TPM_COMM_EVENT;
extern TraceEvent _TRACE_SPAPR_TPM_EXECUTE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PUT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_GET_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_STUFF_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_PUT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_GET_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_STUFF_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_XLATE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_NEW_TABLE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PRE_SAVE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_POST_LOAD_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_QUERY_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_CREATE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_REMOVE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_RESET_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_DR_INDICATOR_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_CONFIGURED_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_ATTACH_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_DETACH_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_AWAITING_QUIESCE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_RESET_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_CHILD_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_COMPLETE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_UNREALIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_OVEC_PARSE_VECTOR_EVENT;
extern TraceEvent _TRACE_SPAPR_OVEC_POPULATE_DT_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_EVENT;
extern TraceEvent _TRACE_SPAPR_VIO_H_REG_CRQ_EVENT;
extern TraceEvent _TRACE_SPAPR_VIO_FREE_CRQ_EVENT;
extern TraceEvent _TRACE_PPC_TB_ADJUST_EVENT;
extern TraceEvent _TRACE_PREP_SYSTEMIO_READ_EVENT;
extern TraceEvent _TRACE_PREP_SYSTEMIO_WRITE_EVENT;
extern TraceEvent _TRACE_RS6000MC_ID_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_PRESENCE_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_SIZE_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_SIZE_WRITE_EVENT;
extern TraceEvent _TRACE_RS6000MC_PARITY_READ_EVENT;
extern TraceEvent _TRACE_PPC4XX_PCI_MAP_IRQ_EVENT;
extern TraceEvent _TRACE_PPC4XX_PCI_SET_IRQ_EVENT;
extern TraceEvent _TRACE_PPC440_PCIX_MAP_IRQ_EVENT;
extern TraceEvent _TRACE_PPC440_PCIX_SET_IRQ_EVENT;
extern TraceEvent _TRACE_PPC440_PCIX_UPDATE_PIM_EVENT;
extern TraceEvent _TRACE_PPC440_PCIX_UPDATE_POM_EVENT;
extern TraceEvent _TRACE_PPC440_PCIX_REG_READ_EVENT;
extern TraceEvent _TRACE_PPC440_PCIX_REG_WRITE_EVENT;
extern uint16_t _TRACE_SPAPR_PCI_MSI_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_SETUP_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_WRITE_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_LSI_SET_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_RETRY_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_CONTINUE_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_PVR_DSTATE;
extern uint16_t _TRACE_SPAPR_H_RESIZE_HPT_PREPARE_DSTATE;
extern uint16_t _TRACE_SPAPR_H_RESIZE_HPT_COMMIT_DSTATE;
extern uint16_t _TRACE_SPAPR_UPDATE_DT_DSTATE;
extern uint16_t _TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_DSTATE;
extern uint16_t _TRACE_SPAPR_H_TPM_COMM_DSTATE;
extern uint16_t _TRACE_SPAPR_TPM_EXECUTE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PUT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_GET_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_STUFF_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_PUT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_GET_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_STUFF_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_XLATE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_NEW_TABLE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PRE_SAVE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_POST_LOAD_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_QUERY_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_CREATE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_REMOVE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_RESET_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_DR_INDICATOR_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_CONFIGURED_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_ATTACH_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_DETACH_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_AWAITING_QUIESCE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_RESET_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_CHILD_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_COMPLETE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_UNREALIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_OVEC_PARSE_VECTOR_DSTATE;
extern uint16_t _TRACE_SPAPR_OVEC_POPULATE_DT_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_DSTATE;
extern uint16_t _TRACE_SPAPR_VIO_H_REG_CRQ_DSTATE;
extern uint16_t _TRACE_SPAPR_VIO_FREE_CRQ_DSTATE;
extern uint16_t _TRACE_PPC_TB_ADJUST_DSTATE;
extern uint16_t _TRACE_PREP_SYSTEMIO_READ_DSTATE;
extern uint16_t _TRACE_PREP_SYSTEMIO_WRITE_DSTATE;
extern uint16_t _TRACE_RS6000MC_ID_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_PRESENCE_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_SIZE_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_SIZE_WRITE_DSTATE;
extern uint16_t _TRACE_RS6000MC_PARITY_READ_DSTATE;
extern uint16_t _TRACE_PPC4XX_PCI_MAP_IRQ_DSTATE;
extern uint16_t _TRACE_PPC4XX_PCI_SET_IRQ_DSTATE;
extern uint16_t _TRACE_PPC440_PCIX_MAP_IRQ_DSTATE;
extern uint16_t _TRACE_PPC440_PCIX_SET_IRQ_DSTATE;
extern uint16_t _TRACE_PPC440_PCIX_UPDATE_PIM_DSTATE;
extern uint16_t _TRACE_PPC440_PCIX_UPDATE_POM_DSTATE;
extern uint16_t _TRACE_PPC440_PCIX_REG_READ_DSTATE;
extern uint16_t _TRACE_PPC440_PCIX_REG_WRITE_DSTATE;
#define TRACE_SPAPR_PCI_MSI_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_SETUP_ENABLED 1
#define TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_ENABLED 1
#define TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_WRITE_ENABLED 1
#define TRACE_SPAPR_PCI_LSI_SET_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_RETRY_ENABLED 1
#define TRACE_SPAPR_CAS_CONTINUE_ENABLED 1
#define TRACE_SPAPR_CAS_PVR_ENABLED 1
#define TRACE_SPAPR_H_RESIZE_HPT_PREPARE_ENABLED 1
#define TRACE_SPAPR_H_RESIZE_HPT_COMMIT_ENABLED 1
#define TRACE_SPAPR_UPDATE_DT_ENABLED 1
#define TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_ENABLED 1
#define TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_ENABLED 1
#define TRACE_SPAPR_H_TPM_COMM_ENABLED 1
#define TRACE_SPAPR_TPM_EXECUTE_ENABLED 1
#define TRACE_SPAPR_IOMMU_PUT_ENABLED 1
#define TRACE_SPAPR_IOMMU_GET_ENABLED 1
#define TRACE_SPAPR_IOMMU_INDIRECT_ENABLED 1
#define TRACE_SPAPR_IOMMU_STUFF_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_PUT_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_GET_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_INDIRECT_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_STUFF_ENABLED 1
#define TRACE_SPAPR_IOMMU_XLATE_ENABLED 1
#define TRACE_SPAPR_IOMMU_NEW_TABLE_ENABLED 1
#define TRACE_SPAPR_IOMMU_PRE_SAVE_ENABLED 1
#define TRACE_SPAPR_IOMMU_POST_LOAD_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_QUERY_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_CREATE_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_REMOVE_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_RESET_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_ENABLED 1
#define TRACE_SPAPR_DRC_SET_DR_INDICATOR_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_ENABLED 1
#define TRACE_SPAPR_DRC_SET_CONFIGURED_ENABLED 1
#define TRACE_SPAPR_DRC_ATTACH_ENABLED 1
#define TRACE_SPAPR_DRC_DETACH_ENABLED 1
#define TRACE_SPAPR_DRC_AWAITING_QUIESCE_ENABLED 1
#define TRACE_SPAPR_DRC_RESET_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_CHILD_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_COMPLETE_ENABLED 1
#define TRACE_SPAPR_DRC_UNREALIZE_ENABLED 1
#define TRACE_SPAPR_OVEC_PARSE_VECTOR_ENABLED 1
#define TRACE_SPAPR_OVEC_POPULATE_DT_ENABLED 1
#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_ENABLED 1
#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_ENABLED 1
#define TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_ENABLED 1
#define TRACE_SPAPR_VIO_H_REG_CRQ_ENABLED 1
#define TRACE_SPAPR_VIO_FREE_CRQ_ENABLED 1
#define TRACE_PPC_TB_ADJUST_ENABLED 1
#define TRACE_PREP_SYSTEMIO_READ_ENABLED 1
#define TRACE_PREP_SYSTEMIO_WRITE_ENABLED 1
#define TRACE_RS6000MC_ID_READ_ENABLED 1
#define TRACE_RS6000MC_PRESENCE_READ_ENABLED 1
#define TRACE_RS6000MC_SIZE_READ_ENABLED 1
#define TRACE_RS6000MC_SIZE_WRITE_ENABLED 1
#define TRACE_RS6000MC_PARITY_READ_ENABLED 1
#define TRACE_PPC4XX_PCI_MAP_IRQ_ENABLED 1
#define TRACE_PPC4XX_PCI_SET_IRQ_ENABLED 1
#define TRACE_PPC440_PCIX_MAP_IRQ_ENABLED 1
#define TRACE_PPC440_PCIX_SET_IRQ_ENABLED 1
#define TRACE_PPC440_PCIX_UPDATE_PIM_ENABLED 1
#define TRACE_PPC440_PCIX_UPDATE_POM_ENABLED 1
#define TRACE_PPC440_PCIX_REG_READ_ENABLED 1
#define TRACE_PPC440_PCIX_REG_WRITE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_SPAPR_PCI_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi(const char * msg, uint32_t ca)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi " "%s (cfg=0x%x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg, ca);
#line 235 "trace/trace-hw_ppc.h"
        } else {
#line 4 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_pci_msi " "%s (cfg=0x%x)" "\n", msg, ca);
#line 239 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi(const char * msg, uint32_t ca)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi(msg, ca);
    }
}

#define TRACE_SPAPR_PCI_MSI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI_SETUP) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi_setup(const char * name, unsigned vector, uint64_t addr)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_SETUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi_setup " "dev\"%s\" vector %u, addr=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, vector, addr);
#line 266 "trace/trace-hw_ppc.h"
        } else {
#line 5 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_pci_msi_setup " "dev\"%s\" vector %u, addr=0x%"PRIx64 "\n", name, vector, addr);
#line 270 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi_setup(const char * name, unsigned vector, uint64_t addr)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi_setup(name, vector, addr);
    }
}

#define TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI) || \
    false)

static inline void _nocheck__trace_spapr_pci_rtas_ibm_change_msi(unsigned cfg, unsigned func, unsigned req, unsigned first)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_rtas_ibm_change_msi " "cfgaddr 0x%x func %u, requested %u, first irq %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cfg, func, req, first);
#line 297 "trace/trace-hw_ppc.h"
        } else {
#line 6 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_pci_rtas_ibm_change_msi " "cfgaddr 0x%x func %u, requested %u, first irq %u" "\n", cfg, func, req, first);
#line 301 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_rtas_ibm_change_msi(unsigned cfg, unsigned func, unsigned req, unsigned first)
{
    if (true) {
        _nocheck__trace_spapr_pci_rtas_ibm_change_msi(cfg, func, req, first);
    }
}

#define TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER) || \
    false)

static inline void _nocheck__trace_spapr_pci_rtas_ibm_query_interrupt_source_number(unsigned ioa, unsigned intr)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_rtas_ibm_query_interrupt_source_number " "queries for #%u, IRQ%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ioa, intr);
#line 328 "trace/trace-hw_ppc.h"
        } else {
#line 7 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_pci_rtas_ibm_query_interrupt_source_number " "queries for #%u, IRQ%u" "\n", ioa, intr);
#line 332 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_rtas_ibm_query_interrupt_source_number(unsigned ioa, unsigned intr)
{
    if (true) {
        _nocheck__trace_spapr_pci_rtas_ibm_query_interrupt_source_number(ioa, intr);
    }
}

#define TRACE_SPAPR_PCI_MSI_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI_WRITE) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi_write(uint64_t addr, uint64_t data, uint32_t dt_irq)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi_write " "@0x%"PRIx64"<=0x%"PRIx64" IRQ %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, dt_irq);
#line 359 "trace/trace-hw_ppc.h"
        } else {
#line 8 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_pci_msi_write " "@0x%"PRIx64"<=0x%"PRIx64" IRQ %u" "\n", addr, data, dt_irq);
#line 363 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi_write(uint64_t addr, uint64_t data, uint32_t dt_irq)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi_write(addr, data, dt_irq);
    }
}

#define TRACE_SPAPR_PCI_LSI_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_LSI_SET) || \
    false)

static inline void _nocheck__trace_spapr_pci_lsi_set(const char * busname, int pin, uint32_t irq)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_LSI_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_lsi_set " "%s PIN%d IRQ %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , busname, pin, irq);
#line 390 "trace/trace-hw_ppc.h"
        } else {
#line 9 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_pci_lsi_set " "%s PIN%d IRQ %u" "\n", busname, pin, irq);
#line 394 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_lsi_set(const char * busname, int pin, uint32_t irq)
{
    if (true) {
        _nocheck__trace_spapr_pci_lsi_set(busname, pin, irq);
    }
}

#define TRACE_SPAPR_PCI_MSI_RETRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_PCI_MSI_RETRY) || \
    false)

static inline void _nocheck__trace_spapr_pci_msi_retry(unsigned config_addr, unsigned req_num, unsigned max_irqs)
{
    if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_RETRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_pci_msi_retry " "Guest device at 0x%x asked %u, have only %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , config_addr, req_num, max_irqs);
#line 421 "trace/trace-hw_ppc.h"
        } else {
#line 10 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_pci_msi_retry " "Guest device at 0x%x asked %u, have only %u" "\n", config_addr, req_num, max_irqs);
#line 425 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_pci_msi_retry(unsigned config_addr, unsigned req_num, unsigned max_irqs)
{
    if (true) {
        _nocheck__trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);
    }
}

#define TRACE_SPAPR_CAS_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_CAS_CONTINUE) || \
    false)

static inline void _nocheck__trace_spapr_cas_continue(unsigned long n)
{
    if (trace_event_get_state(TRACE_SPAPR_CAS_CONTINUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_cas_continue " "Copy changes to the guest: %ld bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , n);
#line 452 "trace/trace-hw_ppc.h"
        } else {
#line 13 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_cas_continue " "Copy changes to the guest: %ld bytes" "\n", n);
#line 456 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_cas_continue(unsigned long n)
{
    if (true) {
        _nocheck__trace_spapr_cas_continue(n);
    }
}

#define TRACE_SPAPR_CAS_PVR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_CAS_PVR) || \
    false)

static inline void _nocheck__trace_spapr_cas_pvr(uint32_t cur_pvr, bool explicit_match, uint32_t new_pvr)
{
    if (trace_event_get_state(TRACE_SPAPR_CAS_PVR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_cas_pvr " "current=0x%x, explicit_match=%u, new=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cur_pvr, explicit_match, new_pvr);
#line 483 "trace/trace-hw_ppc.h"
        } else {
#line 14 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_cas_pvr " "current=0x%x, explicit_match=%u, new=0x%x" "\n", cur_pvr, explicit_match, new_pvr);
#line 487 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_cas_pvr(uint32_t cur_pvr, bool explicit_match, uint32_t new_pvr)
{
    if (true) {
        _nocheck__trace_spapr_cas_pvr(cur_pvr, explicit_match, new_pvr);
    }
}

#define TRACE_SPAPR_H_RESIZE_HPT_PREPARE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_H_RESIZE_HPT_PREPARE) || \
    false)

static inline void _nocheck__trace_spapr_h_resize_hpt_prepare(uint64_t flags, uint64_t shift)
{
    if (trace_event_get_state(TRACE_SPAPR_H_RESIZE_HPT_PREPARE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_h_resize_hpt_prepare " "flags=0x%"PRIx64", shift=%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , flags, shift);
#line 514 "trace/trace-hw_ppc.h"
        } else {
#line 15 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_h_resize_hpt_prepare " "flags=0x%"PRIx64", shift=%"PRIu64 "\n", flags, shift);
#line 518 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_h_resize_hpt_prepare(uint64_t flags, uint64_t shift)
{
    if (true) {
        _nocheck__trace_spapr_h_resize_hpt_prepare(flags, shift);
    }
}

#define TRACE_SPAPR_H_RESIZE_HPT_COMMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_H_RESIZE_HPT_COMMIT) || \
    false)

static inline void _nocheck__trace_spapr_h_resize_hpt_commit(uint64_t flags, uint64_t shift)
{
    if (trace_event_get_state(TRACE_SPAPR_H_RESIZE_HPT_COMMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_h_resize_hpt_commit " "flags=0x%"PRIx64", shift=%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , flags, shift);
#line 545 "trace/trace-hw_ppc.h"
        } else {
#line 16 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_h_resize_hpt_commit " "flags=0x%"PRIx64", shift=%"PRIu64 "\n", flags, shift);
#line 549 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_h_resize_hpt_commit(uint64_t flags, uint64_t shift)
{
    if (true) {
        _nocheck__trace_spapr_h_resize_hpt_commit(flags, shift);
    }
}

#define TRACE_SPAPR_UPDATE_DT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_UPDATE_DT) || \
    false)

static inline void _nocheck__trace_spapr_update_dt(unsigned cb)
{
    if (trace_event_get_state(TRACE_SPAPR_UPDATE_DT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_update_dt " "New blob %u bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cb);
#line 576 "trace/trace-hw_ppc.h"
        } else {
#line 17 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_update_dt " "New blob %u bytes" "\n", cb);
#line 580 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_update_dt(unsigned cb)
{
    if (true) {
        _nocheck__trace_spapr_update_dt(cb);
    }
}

#define TRACE_SPAPR_UPDATE_DT_FAILED_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_UPDATE_DT_FAILED_SIZE) || \
    false)

static inline void _nocheck__trace_spapr_update_dt_failed_size(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (trace_event_get_state(TRACE_SPAPR_UPDATE_DT_FAILED_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_update_dt_failed_size " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cbold, cbnew, magic);
#line 607 "trace/trace-hw_ppc.h"
        } else {
#line 18 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_update_dt_failed_size " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n", cbold, cbnew, magic);
#line 611 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_update_dt_failed_size(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (true) {
        _nocheck__trace_spapr_update_dt_failed_size(cbold, cbnew, magic);
    }
}

#define TRACE_SPAPR_UPDATE_DT_FAILED_CHECK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_UPDATE_DT_FAILED_CHECK) || \
    false)

static inline void _nocheck__trace_spapr_update_dt_failed_check(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (trace_event_get_state(TRACE_SPAPR_UPDATE_DT_FAILED_CHECK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_update_dt_failed_check " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cbold, cbnew, magic);
#line 638 "trace/trace-hw_ppc.h"
        } else {
#line 19 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_update_dt_failed_check " "Old blob %u bytes, new blob %u bytes, magic 0x%x" "\n", cbold, cbnew, magic);
#line 642 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_update_dt_failed_check(unsigned cbold, unsigned cbnew, unsigned magic)
{
    if (true) {
        _nocheck__trace_spapr_update_dt_failed_check(cbold, cbnew, magic);
    }
}

#define TRACE_SPAPR_H_TPM_COMM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_H_TPM_COMM) || \
    false)

static inline void _nocheck__trace_spapr_h_tpm_comm(const char * device_path, uint64_t operation)
{
    if (trace_event_get_state(TRACE_SPAPR_H_TPM_COMM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_h_tpm_comm " "tpm_device_path=%s operation=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , device_path, operation);
#line 669 "trace/trace-hw_ppc.h"
        } else {
#line 22 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_h_tpm_comm " "tpm_device_path=%s operation=0x%"PRIx64 "\n", device_path, operation);
#line 673 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_h_tpm_comm(const char * device_path, uint64_t operation)
{
    if (true) {
        _nocheck__trace_spapr_h_tpm_comm(device_path, operation);
    }
}

#define TRACE_SPAPR_TPM_EXECUTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_TPM_EXECUTE) || \
    false)

static inline void _nocheck__trace_spapr_tpm_execute(uint64_t data_in, uint64_t data_in_sz, uint64_t data_out, uint64_t data_out_sz)
{
    if (trace_event_get_state(TRACE_SPAPR_TPM_EXECUTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_tpm_execute " "data_in=0x%"PRIx64", data_in_sz=%"PRIu64", data_out=0x%"PRIx64", data_out_sz=%"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data_in, data_in_sz, data_out, data_out_sz);
#line 700 "trace/trace-hw_ppc.h"
        } else {
#line 23 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_tpm_execute " "data_in=0x%"PRIx64", data_in_sz=%"PRIu64", data_out=0x%"PRIx64", data_out_sz=%"PRIu64 "\n", data_in, data_in_sz, data_out, data_out_sz);
#line 704 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_tpm_execute(uint64_t data_in, uint64_t data_in_sz, uint64_t data_out, uint64_t data_out_sz)
{
    if (true) {
        _nocheck__trace_spapr_tpm_execute(data_in, data_in_sz, data_out, data_out_sz);
    }
}

#define TRACE_SPAPR_IOMMU_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PUT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, ret);
#line 731 "trace/trace-hw_ppc.h"
        } else {
#line 26 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, ret);
#line 735 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_put(liobn, ioba, tce, ret);
    }
}

#define TRACE_SPAPR_IOMMU_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_GET) || \
    false)

static inline void _nocheck__trace_spapr_iommu_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, ret, tce);
#line 762 "trace/trace-hw_ppc.h"
        } else {
#line 27 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n", liobn, ioba, ret, tce);
#line 766 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (true) {
        _nocheck__trace_spapr_iommu_get(liobn, ioba, ret, tce);
    }
}

#define TRACE_SPAPR_IOMMU_INDIRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_INDIRECT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_INDIRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, iobaN, tceN, ret);
#line 793 "trace/trace-hw_ppc.h"
        } else {
#line 28 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, iobaN, tceN, ret);
#line 797 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_indirect(liobn, ioba, tce, iobaN, tceN, ret);
    }
}

#define TRACE_SPAPR_IOMMU_STUFF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_STUFF) || \
    false)

static inline void _nocheck__trace_spapr_iommu_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_STUFF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce_value, npages, ret);
#line 824 "trace/trace-hw_ppc.h"
        } else {
#line 29 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n", liobn, ioba, tce_value, npages, ret);
#line 828 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_stuff(liobn, ioba, tce_value, npages, ret);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_PUT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, ret);
#line 855 "trace/trace-hw_ppc.h"
        } else {
#line 30 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_put " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, ret);
#line 859 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_put(liobn, ioba, tce, ret);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_GET) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_GET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, ret, tce);
#line 886 "trace/trace-hw_ppc.h"
        } else {
#line 31 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_get " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n", liobn, ioba, ret, tce);
#line 890 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_get(liobn, ioba, ret, tce);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_INDIRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_INDIRECT) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_INDIRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, iobaN, tceN, ret);
#line 917 "trace/trace-hw_ppc.h"
        } else {
#line 32 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_indirect " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n", liobn, ioba, tce, iobaN, tceN, ret);
#line 921 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_indirect(liobn, ioba, tce, iobaN, tceN, ret);
    }
}

#define TRACE_SPAPR_IOMMU_PCI_STUFF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PCI_STUFF) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pci_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_STUFF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pci_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce_value, npages, ret);
#line 948 "trace/trace-hw_ppc.h"
        } else {
#line 33 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_pci_stuff " "liobn=0x%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n", liobn, ioba, tce_value, npages, ret);
#line 952 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pci_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pci_stuff(liobn, ioba, tce_value, npages, ret);
    }
}

#define TRACE_SPAPR_IOMMU_XLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_XLATE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_xlate(uint64_t liobn, uint64_t ioba, uint64_t tce, unsigned perm, unsigned pgsize)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_XLATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_xlate " "liobn=0x%"PRIx64" 0x%"PRIx64" -> 0x%"PRIx64" perm=%u mask=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, ioba, tce, perm, pgsize);
#line 979 "trace/trace-hw_ppc.h"
        } else {
#line 34 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_xlate " "liobn=0x%"PRIx64" 0x%"PRIx64" -> 0x%"PRIx64" perm=%u mask=0x%x" "\n", liobn, ioba, tce, perm, pgsize);
#line 983 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_xlate(uint64_t liobn, uint64_t ioba, uint64_t tce, unsigned perm, unsigned pgsize)
{
    if (true) {
        _nocheck__trace_spapr_iommu_xlate(liobn, ioba, tce, perm, pgsize);
    }
}

#define TRACE_SPAPR_IOMMU_NEW_TABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_NEW_TABLE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_new_table(uint64_t liobn, void * table, int fd)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_NEW_TABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_new_table " "liobn=0x%"PRIx64" table=%p fd=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, table, fd);
#line 1010 "trace/trace-hw_ppc.h"
        } else {
#line 35 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_new_table " "liobn=0x%"PRIx64" table=%p fd=%d" "\n", liobn, table, fd);
#line 1014 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_new_table(uint64_t liobn, void * table, int fd)
{
    if (true) {
        _nocheck__trace_spapr_iommu_new_table(liobn, table, fd);
    }
}

#define TRACE_SPAPR_IOMMU_PRE_SAVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_PRE_SAVE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_pre_save(uint64_t liobn, uint32_t nb, uint64_t offs, uint32_t ps)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_PRE_SAVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_pre_save " "liobn=%"PRIx64" %"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, nb, offs, ps);
#line 1041 "trace/trace-hw_ppc.h"
        } else {
#line 36 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_pre_save " "liobn=%"PRIx64" %"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n", liobn, nb, offs, ps);
#line 1045 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_pre_save(uint64_t liobn, uint32_t nb, uint64_t offs, uint32_t ps)
{
    if (true) {
        _nocheck__trace_spapr_iommu_pre_save(liobn, nb, offs, ps);
    }
}

#define TRACE_SPAPR_IOMMU_POST_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_POST_LOAD) || \
    false)

static inline void _nocheck__trace_spapr_iommu_post_load(uint64_t liobn, uint32_t pre_nb, uint32_t post_nb, uint64_t offs, uint32_t ps)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_POST_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_post_load " "liobn=%"PRIx64" %"PRIx32" => 0x%"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn, pre_nb, post_nb, offs, ps);
#line 1072 "trace/trace-hw_ppc.h"
        } else {
#line 37 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_post_load " "liobn=%"PRIx64" %"PRIx32" => 0x%"PRIx32" bus_offset=0x%"PRIx64" ps=%"PRIu32 "\n", liobn, pre_nb, post_nb, offs, ps);
#line 1076 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_post_load(uint64_t liobn, uint32_t pre_nb, uint32_t post_nb, uint64_t offs, uint32_t ps)
{
    if (true) {
        _nocheck__trace_spapr_iommu_post_load(liobn, pre_nb, post_nb, offs, ps);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_QUERY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_QUERY) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_query(uint64_t buid, uint32_t cfgaddr, unsigned wa, uint64_t win_size, uint32_t pgmask)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_QUERY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_query " "buid=0x%"PRIx64" addr=0x%"PRIx32", %u windows available, max window size=0x%"PRIx64", mask=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buid, cfgaddr, wa, win_size, pgmask);
#line 1103 "trace/trace-hw_ppc.h"
        } else {
#line 40 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_query " "buid=0x%"PRIx64" addr=0x%"PRIx32", %u windows available, max window size=0x%"PRIx64", mask=0x%"PRIx32 "\n", buid, cfgaddr, wa, win_size, pgmask);
#line 1107 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_query(uint64_t buid, uint32_t cfgaddr, unsigned wa, uint64_t win_size, uint32_t pgmask)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_query(buid, cfgaddr, wa, win_size, pgmask);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_CREATE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_create(uint64_t buid, uint32_t cfgaddr, uint64_t pg_size, uint64_t req_size, uint64_t start, uint32_t liobn)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_create " "buid=0x%"PRIx64" addr=0x%"PRIx32", page size=0x%"PRIx64", requested=0x%"PRIx64", start addr=0x%"PRIx64", liobn=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buid, cfgaddr, pg_size, req_size, start, liobn);
#line 1134 "trace/trace-hw_ppc.h"
        } else {
#line 41 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_create " "buid=0x%"PRIx64" addr=0x%"PRIx32", page size=0x%"PRIx64", requested=0x%"PRIx64", start addr=0x%"PRIx64", liobn=0x%"PRIx32 "\n", buid, cfgaddr, pg_size, req_size, start, liobn);
#line 1138 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_create(uint64_t buid, uint32_t cfgaddr, uint64_t pg_size, uint64_t req_size, uint64_t start, uint32_t liobn)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_create(buid, cfgaddr, pg_size, req_size, start, liobn);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_REMOVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_REMOVE) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_remove(uint32_t liobn)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_REMOVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_remove " "liobn=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , liobn);
#line 1165 "trace/trace-hw_ppc.h"
        } else {
#line 42 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_remove " "liobn=0x%"PRIx32 "\n", liobn);
#line 1169 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_remove(uint32_t liobn)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_remove(liobn);
    }
}

#define TRACE_SPAPR_IOMMU_DDW_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_IOMMU_DDW_RESET) || \
    false)

static inline void _nocheck__trace_spapr_iommu_ddw_reset(uint64_t buid, uint32_t cfgaddr)
{
    if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_iommu_ddw_reset " "buid=0x%"PRIx64" addr=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buid, cfgaddr);
#line 1196 "trace/trace-hw_ppc.h"
        } else {
#line 43 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_iommu_ddw_reset " "buid=0x%"PRIx64" addr=0x%"PRIx32 "\n", buid, cfgaddr);
#line 1200 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_iommu_ddw_reset(uint64_t buid, uint32_t cfgaddr)
{
    if (true) {
        _nocheck__trace_spapr_iommu_ddw_reset(buid, cfgaddr);
    }
}

#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ISOLATION_STATE) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_isolation_state(uint32_t index, int state)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ISOLATION_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_isolation_state " "drc: 0x%"PRIx32", state: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, state);
#line 1227 "trace/trace-hw_ppc.h"
        } else {
#line 46 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_set_isolation_state " "drc: 0x%"PRIx32", state: 0x%"PRIx32 "\n", index, state);
#line 1231 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_isolation_state(uint32_t index, int state)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_isolation_state(index, state);
    }
}

#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_isolation_state_finalizing(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_isolation_state_finalizing " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1258 "trace/trace-hw_ppc.h"
        } else {
#line 47 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_set_isolation_state_finalizing " "drc: 0x%"PRIx32 "\n", index);
#line 1262 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_isolation_state_finalizing(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_isolation_state_finalizing(index);
    }
}

#define TRACE_SPAPR_DRC_SET_DR_INDICATOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_DR_INDICATOR) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_dr_indicator(uint32_t index, int state)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_DR_INDICATOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_dr_indicator " "drc: 0x%"PRIx32", state: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, state);
#line 1289 "trace/trace-hw_ppc.h"
        } else {
#line 48 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_set_dr_indicator " "drc: 0x%"PRIx32", state: 0x%x" "\n", index, state);
#line 1293 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_dr_indicator(uint32_t index, int state)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_dr_indicator(index, state);
    }
}

#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_allocation_state(uint32_t index, int state)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_allocation_state " "drc: 0x%"PRIx32", state: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, state);
#line 1320 "trace/trace-hw_ppc.h"
        } else {
#line 49 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_set_allocation_state " "drc: 0x%"PRIx32", state: 0x%x" "\n", index, state);
#line 1324 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_allocation_state(uint32_t index, int state)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_allocation_state(index, state);
    }
}

#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_allocation_state_finalizing(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_allocation_state_finalizing " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1351 "trace/trace-hw_ppc.h"
        } else {
#line 50 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_set_allocation_state_finalizing " "drc: 0x%"PRIx32 "\n", index);
#line 1355 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_allocation_state_finalizing(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_allocation_state_finalizing(index);
    }
}

#define TRACE_SPAPR_DRC_SET_CONFIGURED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_SET_CONFIGURED) || \
    false)

static inline void _nocheck__trace_spapr_drc_set_configured(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_SET_CONFIGURED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_set_configured " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1382 "trace/trace-hw_ppc.h"
        } else {
#line 51 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_set_configured " "drc: 0x%"PRIx32 "\n", index);
#line 1386 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_set_configured(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_set_configured(index);
    }
}

#define TRACE_SPAPR_DRC_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_ATTACH) || \
    false)

static inline void _nocheck__trace_spapr_drc_attach(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_attach " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1413 "trace/trace-hw_ppc.h"
        } else {
#line 52 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_attach " "drc: 0x%"PRIx32 "\n", index);
#line 1417 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_attach(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_attach(index);
    }
}

#define TRACE_SPAPR_DRC_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_DETACH) || \
    false)

static inline void _nocheck__trace_spapr_drc_detach(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_detach " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1444 "trace/trace-hw_ppc.h"
        } else {
#line 53 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_detach " "drc: 0x%"PRIx32 "\n", index);
#line 1448 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_detach(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_detach(index);
    }
}

#define TRACE_SPAPR_DRC_AWAITING_QUIESCE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_AWAITING_QUIESCE) || \
    false)

static inline void _nocheck__trace_spapr_drc_awaiting_quiesce(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_AWAITING_QUIESCE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_awaiting_quiesce " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1475 "trace/trace-hw_ppc.h"
        } else {
#line 54 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_awaiting_quiesce " "drc: 0x%"PRIx32 "\n", index);
#line 1479 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_awaiting_quiesce(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_awaiting_quiesce(index);
    }
}

#define TRACE_SPAPR_DRC_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_RESET) || \
    false)

static inline void _nocheck__trace_spapr_drc_reset(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_reset " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1506 "trace/trace-hw_ppc.h"
        } else {
#line 55 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_reset " "drc: 0x%"PRIx32 "\n", index);
#line 1510 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_reset(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_reset(index);
    }
}

#define TRACE_SPAPR_DRC_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_REALIZE) || \
    false)

static inline void _nocheck__trace_spapr_drc_realize(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_realize " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1537 "trace/trace-hw_ppc.h"
        } else {
#line 56 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_realize " "drc: 0x%"PRIx32 "\n", index);
#line 1541 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_realize(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_realize(index);
    }
}

#define TRACE_SPAPR_DRC_REALIZE_CHILD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_REALIZE_CHILD) || \
    false)

static inline void _nocheck__trace_spapr_drc_realize_child(uint32_t index, const char * childname)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE_CHILD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_realize_child " "drc: 0x%"PRIx32", child name: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, childname);
#line 1568 "trace/trace-hw_ppc.h"
        } else {
#line 57 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_realize_child " "drc: 0x%"PRIx32", child name: %s" "\n", index, childname);
#line 1572 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_realize_child(uint32_t index, const char * childname)
{
    if (true) {
        _nocheck__trace_spapr_drc_realize_child(index, childname);
    }
}

#define TRACE_SPAPR_DRC_REALIZE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_REALIZE_COMPLETE) || \
    false)

static inline void _nocheck__trace_spapr_drc_realize_complete(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_realize_complete " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1599 "trace/trace-hw_ppc.h"
        } else {
#line 58 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_realize_complete " "drc: 0x%"PRIx32 "\n", index);
#line 1603 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_realize_complete(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_realize_complete(index);
    }
}

#define TRACE_SPAPR_DRC_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_DRC_UNREALIZE) || \
    false)

static inline void _nocheck__trace_spapr_drc_unrealize(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_DRC_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_drc_unrealize " "drc: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1630 "trace/trace-hw_ppc.h"
        } else {
#line 59 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_drc_unrealize " "drc: 0x%"PRIx32 "\n", index);
#line 1634 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_drc_unrealize(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_drc_unrealize(index);
    }
}

#define TRACE_SPAPR_OVEC_PARSE_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_OVEC_PARSE_VECTOR) || \
    false)

static inline void _nocheck__trace_spapr_ovec_parse_vector(int vector, int byte, uint16_t vec_len, uint8_t entry)
{
    if (trace_event_get_state(TRACE_SPAPR_OVEC_PARSE_VECTOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_ovec_parse_vector " "read guest vector %2d, byte %3d / %3d: 0x%.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector, byte, vec_len, entry);
#line 1661 "trace/trace-hw_ppc.h"
        } else {
#line 62 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_ovec_parse_vector " "read guest vector %2d, byte %3d / %3d: 0x%.2x" "\n", vector, byte, vec_len, entry);
#line 1665 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_ovec_parse_vector(int vector, int byte, uint16_t vec_len, uint8_t entry)
{
    if (true) {
        _nocheck__trace_spapr_ovec_parse_vector(vector, byte, vec_len, entry);
    }
}

#define TRACE_SPAPR_OVEC_POPULATE_DT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_OVEC_POPULATE_DT) || \
    false)

static inline void _nocheck__trace_spapr_ovec_populate_dt(int byte, uint16_t vec_len, uint8_t entry)
{
    if (trace_event_get_state(TRACE_SPAPR_OVEC_POPULATE_DT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_ovec_populate_dt " "encoding guest vector byte %3d / %3d: 0x%.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , byte, vec_len, entry);
#line 1692 "trace/trace-hw_ppc.h"
        } else {
#line 63 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_ovec_populate_dt " "encoding guest vector byte %3d / %3d: 0x%.2x" "\n", byte, vec_len, entry);
#line 1696 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_ovec_populate_dt(int byte, uint16_t vec_len, uint8_t entry)
{
    if (true) {
        _nocheck__trace_spapr_ovec_populate_dt(byte, vec_len, entry);
    }
}

#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED) || \
    false)

static inline void _nocheck__trace_spapr_rtas_get_sensor_state_not_supported(uint32_t index, uint32_t type)
{
    if (trace_event_get_state(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_rtas_get_sensor_state_not_supported " "sensor index: 0x%"PRIx32", type: %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, type);
#line 1723 "trace/trace-hw_ppc.h"
        } else {
#line 66 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_rtas_get_sensor_state_not_supported " "sensor index: 0x%"PRIx32", type: %"PRIu32 "\n", index, type);
#line 1727 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_rtas_get_sensor_state_not_supported(uint32_t index, uint32_t type)
{
    if (true) {
        _nocheck__trace_spapr_rtas_get_sensor_state_not_supported(index, type);
    }
}

#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID) || \
    false)

static inline void _nocheck__trace_spapr_rtas_get_sensor_state_invalid(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_rtas_get_sensor_state_invalid " "sensor index: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1754 "trace/trace-hw_ppc.h"
        } else {
#line 67 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_rtas_get_sensor_state_invalid " "sensor index: 0x%"PRIx32 "\n", index);
#line 1758 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_rtas_get_sensor_state_invalid(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_rtas_get_sensor_state_invalid(index);
    }
}

#define TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID) || \
    false)

static inline void _nocheck__trace_spapr_rtas_ibm_configure_connector_invalid(uint32_t index)
{
    if (trace_event_get_state(TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_rtas_ibm_configure_connector_invalid " "DRC index: 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 1785 "trace/trace-hw_ppc.h"
        } else {
#line 68 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_rtas_ibm_configure_connector_invalid " "DRC index: 0x%"PRIx32 "\n", index);
#line 1789 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_rtas_ibm_configure_connector_invalid(uint32_t index)
{
    if (true) {
        _nocheck__trace_spapr_rtas_ibm_configure_connector_invalid(index);
    }
}

#define TRACE_SPAPR_VIO_H_REG_CRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VIO_H_REG_CRQ) || \
    false)

static inline void _nocheck__trace_spapr_vio_h_reg_crq(uint64_t reg, uint64_t queue_addr, uint64_t queue_len)
{
    if (trace_event_get_state(TRACE_SPAPR_VIO_H_REG_CRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vio_h_reg_crq " "CRQ for dev 0x%" PRIx64 " registered at 0x%" PRIx64 "/0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, queue_addr, queue_len);
#line 1816 "trace/trace-hw_ppc.h"
        } else {
#line 71 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_vio_h_reg_crq " "CRQ for dev 0x%" PRIx64 " registered at 0x%" PRIx64 "/0x%" PRIx64 "\n", reg, queue_addr, queue_len);
#line 1820 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_vio_h_reg_crq(uint64_t reg, uint64_t queue_addr, uint64_t queue_len)
{
    if (true) {
        _nocheck__trace_spapr_vio_h_reg_crq(reg, queue_addr, queue_len);
    }
}

#define TRACE_SPAPR_VIO_FREE_CRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VIO_FREE_CRQ) || \
    false)

static inline void _nocheck__trace_spapr_vio_free_crq(uint32_t reg)
{
    if (trace_event_get_state(TRACE_SPAPR_VIO_FREE_CRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vio_free_crq " "CRQ for dev 0x%" PRIx32 " freed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg);
#line 1847 "trace/trace-hw_ppc.h"
        } else {
#line 72 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("spapr_vio_free_crq " "CRQ for dev 0x%" PRIx32 " freed" "\n", reg);
#line 1851 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_spapr_vio_free_crq(uint32_t reg)
{
    if (true) {
        _nocheck__trace_spapr_vio_free_crq(reg);
    }
}

#define TRACE_PPC_TB_ADJUST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC_TB_ADJUST) || \
    false)

static inline void _nocheck__trace_ppc_tb_adjust(uint64_t offs1, uint64_t offs2, int64_t diff, int64_t seconds)
{
    if (trace_event_get_state(TRACE_PPC_TB_ADJUST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc_tb_adjust " "adjusted from 0x%"PRIx64" to 0x%"PRIx64", diff %"PRId64" (%"PRId64"s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offs1, offs2, diff, seconds);
#line 1878 "trace/trace-hw_ppc.h"
        } else {
#line 75 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc_tb_adjust " "adjusted from 0x%"PRIx64" to 0x%"PRIx64", diff %"PRId64" (%"PRId64"s)" "\n", offs1, offs2, diff, seconds);
#line 1882 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc_tb_adjust(uint64_t offs1, uint64_t offs2, int64_t diff, int64_t seconds)
{
    if (true) {
        _nocheck__trace_ppc_tb_adjust(offs1, offs2, diff, seconds);
    }
}

#define TRACE_PREP_SYSTEMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PREP_SYSTEMIO_READ) || \
    false)

static inline void _nocheck__trace_prep_systemio_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_PREP_SYSTEMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:prep_systemio_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1909 "trace/trace-hw_ppc.h"
        } else {
#line 79 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("prep_systemio_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 1913 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_prep_systemio_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_prep_systemio_read(addr, val);
    }
}

#define TRACE_PREP_SYSTEMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PREP_SYSTEMIO_WRITE) || \
    false)

static inline void _nocheck__trace_prep_systemio_write(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_PREP_SYSTEMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:prep_systemio_write " "write addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1940 "trace/trace-hw_ppc.h"
        } else {
#line 80 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("prep_systemio_write " "write addr=0x%x val=0x%x" "\n", addr, val);
#line 1944 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_prep_systemio_write(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_prep_systemio_write(addr, val);
    }
}

#define TRACE_RS6000MC_ID_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_ID_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_id_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_ID_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_id_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 1971 "trace/trace-hw_ppc.h"
        } else {
#line 83 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("rs6000mc_id_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 1975 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_id_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_id_read(addr, val);
    }
}

#define TRACE_RS6000MC_PRESENCE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_PRESENCE_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_presence_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_PRESENCE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_presence_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2002 "trace/trace-hw_ppc.h"
        } else {
#line 84 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("rs6000mc_presence_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 2006 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_presence_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_presence_read(addr, val);
    }
}

#define TRACE_RS6000MC_SIZE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_SIZE_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_size_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_SIZE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_size_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2033 "trace/trace-hw_ppc.h"
        } else {
#line 85 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("rs6000mc_size_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 2037 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_size_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_size_read(addr, val);
    }
}

#define TRACE_RS6000MC_SIZE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_SIZE_WRITE) || \
    false)

static inline void _nocheck__trace_rs6000mc_size_write(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_SIZE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_size_write " "write addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2064 "trace/trace-hw_ppc.h"
        } else {
#line 86 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("rs6000mc_size_write " "write addr=0x%x val=0x%x" "\n", addr, val);
#line 2068 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_size_write(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_size_write(addr, val);
    }
}

#define TRACE_RS6000MC_PARITY_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_RS6000MC_PARITY_READ) || \
    false)

static inline void _nocheck__trace_rs6000mc_parity_read(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_RS6000MC_PARITY_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:rs6000mc_parity_read " "read addr=0x%x val=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2095 "trace/trace-hw_ppc.h"
        } else {
#line 87 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("rs6000mc_parity_read " "read addr=0x%x val=0x%x" "\n", addr, val);
#line 2099 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_rs6000mc_parity_read(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_rs6000mc_parity_read(addr, val);
    }
}

#define TRACE_PPC4XX_PCI_MAP_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_PCI_MAP_IRQ) || \
    false)

static inline void _nocheck__trace_ppc4xx_pci_map_irq(int32_t devfn, int irq_num, int slot)
{
    if (trace_event_get_state(TRACE_PPC4XX_PCI_MAP_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_pci_map_irq " "devfn 0x%x irq %d -> %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , devfn, irq_num, slot);
#line 2126 "trace/trace-hw_ppc.h"
        } else {
#line 90 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc4xx_pci_map_irq " "devfn 0x%x irq %d -> %d" "\n", devfn, irq_num, slot);
#line 2130 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_pci_map_irq(int32_t devfn, int irq_num, int slot)
{
    if (true) {
        _nocheck__trace_ppc4xx_pci_map_irq(devfn, irq_num, slot);
    }
}

#define TRACE_PPC4XX_PCI_SET_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC4XX_PCI_SET_IRQ) || \
    false)

static inline void _nocheck__trace_ppc4xx_pci_set_irq(int irq_num)
{
    if (trace_event_get_state(TRACE_PPC4XX_PCI_SET_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc4xx_pci_set_irq " "PCI irq %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq_num);
#line 2157 "trace/trace-hw_ppc.h"
        } else {
#line 91 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc4xx_pci_set_irq " "PCI irq %d" "\n", irq_num);
#line 2161 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc4xx_pci_set_irq(int irq_num)
{
    if (true) {
        _nocheck__trace_ppc4xx_pci_set_irq(irq_num);
    }
}

#define TRACE_PPC440_PCIX_MAP_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC440_PCIX_MAP_IRQ) || \
    false)

static inline void _nocheck__trace_ppc440_pcix_map_irq(int32_t devfn, int irq_num, int slot)
{
    if (trace_event_get_state(TRACE_PPC440_PCIX_MAP_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc440_pcix_map_irq " "devfn 0x%x irq %d -> %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , devfn, irq_num, slot);
#line 2188 "trace/trace-hw_ppc.h"
        } else {
#line 94 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc440_pcix_map_irq " "devfn 0x%x irq %d -> %d" "\n", devfn, irq_num, slot);
#line 2192 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc440_pcix_map_irq(int32_t devfn, int irq_num, int slot)
{
    if (true) {
        _nocheck__trace_ppc440_pcix_map_irq(devfn, irq_num, slot);
    }
}

#define TRACE_PPC440_PCIX_SET_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC440_PCIX_SET_IRQ) || \
    false)

static inline void _nocheck__trace_ppc440_pcix_set_irq(int irq_num)
{
    if (trace_event_get_state(TRACE_PPC440_PCIX_SET_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc440_pcix_set_irq " "PCI irq %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , irq_num);
#line 2219 "trace/trace-hw_ppc.h"
        } else {
#line 95 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc440_pcix_set_irq " "PCI irq %d" "\n", irq_num);
#line 2223 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc440_pcix_set_irq(int irq_num)
{
    if (true) {
        _nocheck__trace_ppc440_pcix_set_irq(irq_num);
    }
}

#define TRACE_PPC440_PCIX_UPDATE_PIM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC440_PCIX_UPDATE_PIM) || \
    false)

static inline void _nocheck__trace_ppc440_pcix_update_pim(int idx, uint64_t size, uint64_t la)
{
    if (trace_event_get_state(TRACE_PPC440_PCIX_UPDATE_PIM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc440_pcix_update_pim " "Added window %d of size=0x%" PRIx64 " to CPU=0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, size, la);
#line 2250 "trace/trace-hw_ppc.h"
        } else {
#line 96 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc440_pcix_update_pim " "Added window %d of size=0x%" PRIx64 " to CPU=0x%" PRIx64 "\n", idx, size, la);
#line 2254 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc440_pcix_update_pim(int idx, uint64_t size, uint64_t la)
{
    if (true) {
        _nocheck__trace_ppc440_pcix_update_pim(idx, size, la);
    }
}

#define TRACE_PPC440_PCIX_UPDATE_POM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC440_PCIX_UPDATE_POM) || \
    false)

static inline void _nocheck__trace_ppc440_pcix_update_pom(int idx, uint32_t size, uint64_t la, uint64_t pcia)
{
    if (trace_event_get_state(TRACE_PPC440_PCIX_UPDATE_POM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc440_pcix_update_pom " "Added window %d of size=0x%x from CPU=0x%" PRIx64 " to PCI=0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idx, size, la, pcia);
#line 2281 "trace/trace-hw_ppc.h"
        } else {
#line 97 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc440_pcix_update_pom " "Added window %d of size=0x%x from CPU=0x%" PRIx64 " to PCI=0x%" PRIx64 "\n", idx, size, la, pcia);
#line 2285 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc440_pcix_update_pom(int idx, uint32_t size, uint64_t la, uint64_t pcia)
{
    if (true) {
        _nocheck__trace_ppc440_pcix_update_pom(idx, size, la, pcia);
    }
}

#define TRACE_PPC440_PCIX_REG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC440_PCIX_REG_READ) || \
    false)

static inline void _nocheck__trace_ppc440_pcix_reg_read(uint64_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_PPC440_PCIX_REG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc440_pcix_reg_read " "addr 0x%" PRIx64 " = 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 2312 "trace/trace-hw_ppc.h"
        } else {
#line 98 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc440_pcix_reg_read " "addr 0x%" PRIx64 " = 0x%" PRIx32 "\n", addr, val);
#line 2316 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc440_pcix_reg_read(uint64_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_ppc440_pcix_reg_read(addr, val);
    }
}

#define TRACE_PPC440_PCIX_REG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPC440_PCIX_REG_WRITE) || \
    false)

static inline void _nocheck__trace_ppc440_pcix_reg_write(uint64_t addr, uint32_t val, uint32_t size)
{
    if (trace_event_get_state(TRACE_PPC440_PCIX_REG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("%d@%zu.%06zu:ppc440_pcix_reg_write " "addr 0x%" PRIx64 " = 0x%" PRIx32 " size 0x%" PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val, size);
#line 2343 "trace/trace-hw_ppc.h"
        } else {
#line 99 "/home/lore/MasterThesis/qemu/hw/ppc/trace-events"
            qemu_log("ppc440_pcix_reg_write " "addr 0x%" PRIx64 " = 0x%" PRIx32 " size 0x%" PRIx32 "\n", addr, val, size);
#line 2347 "trace/trace-hw_ppc.h"
        }
    }
}

static inline void trace_ppc440_pcix_reg_write(uint64_t addr, uint32_t val, uint32_t size)
{
    if (true) {
        _nocheck__trace_ppc440_pcix_reg_write(addr, val, size);
    }
}
#endif /* TRACE_HW_PPC_GENERATED_TRACERS_H */
